# 数据结构学习

标签（空格分隔）： learning

---

## 第一章：绪论
### 1.1数据结构的讨论范畴
**算法** + **数据结构** = **程序设计**

* 程序设计：为计算机处理问题编制一组指令集
* 算法：处理问题的策略
* 数据结构：问题的数学模型（如何表示数据）
* 数学模型：线性代数方程组、环流模式方程组等，通过以数学方程式来表示显示生活中的问题，从而求得问题的解。
综合各种程序设计问题，抽取它的物理含义，就可以得到几类数学模型。数值计算数值模型、非数值计算模型。
* 数值计算数学模型：计算机求解的问题，就是计算数学所要研究的问题
* 非数值计算数学模型：数学模型的表示和求解的方法，就是数据结构研究的内容。

### 1.2基本概念
* 数据元素：数据中的一个“个体”，数据结构中讨论的基本单位（但是不是最小单位）
* 数据项：数据结构中讨论的最小单位，数据元素是数据项的结合

**组合项**
数据结构：带结构的数据元素的集合（结构：指的是数据元素之间存在的约束关系）
数据结构中讨论的数据都不是孤立的，而是存在一定的关系（位置，次序关系等）
同样的数据元素，不同的关系构成了不同的结构

数据的逻辑结构可归结为以下四类：

* 线性结构：一维数组
* 树形结构：树
* 图状结构：网
* 集合结构：和数学的集合概念是相同的

数据结构的形式定义为：
 数据结构是一个二元素
   Data_Structures = (D, S)
其中：D是数据元素的有限集，S是D上关系（一般指逻辑关系）的有限集。
数据的存储结构：怎样在计算机里面表示数据的逻辑结构
存储结构：逻辑结构在存储器中的映像（表示）
数据元素的映像方法：
用二进制位（BIT）的位串表示数据元素 
关系的映像方法：（所有的关系都可以用有序对的集合表示<x,y>）
可以把有序对看成是关系的基本单位，讨论关系的映像就是讨论有序对的映像方法
有序对<x,y>在计算机中有两种表示方法
顺序映像：以存储位置的相邻来表示后继关系
链式映像：以附加信息（指针）表示后继关系（结构中x, y之间没有固定存储位置关系）
节点：数据元素映像，指向后继元素的指针
在不同的编程环境中，存储结构可有不同的描述方法

数据类型：一个值的集合和定义在此集合上的一组操作的总称
         也可以看做是一个数据结构和定义在这个数据结构上的一组操作

抽象数据类型：数学模型以及定义在此数学模型上的一组操作
用ADT讨论数据结构有什么好处呢？
ADT有两个重要的特征：
数据抽象（强调其本质特征，其所能完成的功能以及它和外部用户的接口）
数据封装 （外部特性和其内部实现细节分析）

抽象数据类型的描述方法：
抽象数据类型可以用（D, S, P）三元组表示
其中，D是数据对象，S是D上的关系集，P是对D的基本操作集

数据结构的讨论和操作是分不开的，所以都是从抽象数据类型的角度讨论数据结构
数据结构和它的操作在实质上是一个整体

抽象数据类型的表示和实现
抽象数据类型需要通过固有数据类型（高级程序设计语言中已实现的数据类型）来实现

### 1.3算法和算法的衡量
一、算法
算法是为了解决某类问题而规定的一个有限长的操作序列。（算法是对问题求解的一种描述）
一个算法必须满足一下五个重要特征：
有穷性：对于任意一组合法输入值，在执行有穷步骤之后一定能结束，算法中的每个步骤都能在有限时间（不是数学上的有限，而是合理的）内完成。
确定性：对于每一种情况应该执行的操作在算法里都应该有明确的规定。并且对于同样的输入，在任何条件下，算法都只有一条执行路径。
可行性：算法中的所有操作都 必须足够基本，都可以通过已经实现的基本操作运算有限次实现。
有输入：作为算法加工对象的量值，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入，而有的算法表面上没有输入，实际上已被嵌入算法之中。
有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种去顶关系即为算法的功能。

2、算法设计的原则
设计算法是，通常应考虑达到以下目标：
正确性：首先，算法应当满足以特定的“规格说明”方式给出的需求（用户的要求）。其次，对算法是否正确的理解可以额有四个层次：a.程序中不含语法错误；b.算法对于几组输入数据能够得出满足要求的结果；c.对于精心算泽的、典型、苛刻且带有刁难性的几组输入数据能够得到满足要求的结果（如除数为0）；d.程序对于一切合法的输入数据都能得出满足要求的结果（很难，我们在设计软件是不可能吧所有合法输入考虑到，因此存在软件维护）通常以第c层的意义的正确性作为衡量一个算法是否合格的标准。
可读性：算法主要是为了人的阅读与交流，其次才是为计算机执行。因此算法应该易于人的理解；领一方面，晦涩难度的程序易于隐藏较多错误而难以调试；
健壮性：（和正确性相联系的）当输入的数据非法时，算法应当恰当地作出放映或进行相应处理，而不是产生莫名其妙的输出结果。并其，处理出错的方法不应是中断程序的执行，而是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。
高效率和低存储量需求：通常，算法的效率指的是算法执行时间；存储量指的是算法执行过程中所需的最大存储空间。两者都与问题的规模有关。

三、算法效率的衡量方法和准则
通常有两种衡量算法效率的方法：
事后统计法（写一个算法对应的程序，执行，然后计算时间）
缺点：必须执行程序；其他因素掩盖算法本质
事前分析估算法（设计算法时的工作）
和算法执行时间相关的因素：
1、算法选用的策略
2、问题的规模
3、编写程序的语言
4、编译程序产生的机器代码的质量
5、计算机执行指令的速度
后三条是和计算机软件、硬件有关的，和算法设计无关，所以设计算法的时候不在考虑后3条
一个特定算法的“运行工作量”的大小，只依赖于问题的规模（通常用整数量n表示），或者说它是问题规模的函数。

T(n)=O(f(n))  （算法的执行时间的增长率和f(n)的增长率相同）
称T(n)为算法的（渐进）时间复杂度
算法=控制结构+原操作（固有数据类型的操作）
算法的执行时间=∑原操作（i）的执行次数*原操作(i)的执行时间
算法的执行时间与原操作执行次数之和成正比（原操作执行时间在不同的算法是一样的）
从算法中选取一种对于研究的问题来说是基本操作的原操作（在所有原操作里起确定性作用），以该基本操作在算法中重复执行次数作为算法运行时间的衡量准则
也可以用语句频度的函数作为算法时间复杂度函数
如果算法效率和输入数据有关，一般没有特殊指出的情况下，算法时间复杂度已最坏情况为标准。有的情况可以考虑平均时间复杂度（统计概率的情况下）。
一般说算法的时间复杂度，就是指在最坏情况下的算法渐进时间复杂度。
四、算法的存储空间需求
算法的空间复杂度   S(n)=O(g(n)) 表示随着问题规模n的增大，算法运行所需要的存储量的增长率和g(n)的增长率相同
算法的存储量包括：
1、输入数据所占空间；有的情况下，不同的算法策略，输入数据所占空间都是相同的
2、程序本身所占的空间；这个差别是细微的，一般情况下可以不考虑
3、辅助变量所占空间；
若输入数据所占空间只取决与问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间
若所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作。
若所需存储量依赖于特定的输入，则通常按最坏的情况考虑（和时间复杂度类似）

## 第二章：线性表（最简单的数据结构）
线性结构是一个数据元素的有序（次序上的有序而不是数值上的有序）集

线性结构的基本特征:
1、集合中必存在唯一的一个“第一个元素”；
2、集合中必存在唯一的一个“最后元素”；
3、除最后元素在外，均有唯一的后继；
4、除第一元素之外，均有唯一的前驱。

### 2.1 线性表的类型定义（现在讨论数据结构都是从ADT的角度讨论）
抽象数据类型线性表的定义如下：（3个要素）
ADT List{
数据对象：
  D = {ai | ai ∈ ElemSet, i=1, 2 , ..., n, n>=0}
         称n为线性表的表长；称n=0时的线性表为空表。
数据关系：
  R1 = {<ai-1, ai>|ai-1, ai ∈ D，i = 2,...n}
  设线性表为（a1, a2,..., ai,... an）,称i为a在线性表中的位序。
}
基本操作：
{结构的初始化}
 InitList(&l) 操作结果：构造一个空的线性表L
{销毁结构}
 DestroyList(&L)
 初始条件：线性表L存在
 操作结果：销毁线性表L
 {引用型操作}（7个操作）操作结果不改变结构，所以称为引用型操作
 ListEmpty(L)
 ListLength(L)
 PriorElem(;, cur_e,&pre_e)
 NextElem(L, cur_e, &next_e)
 GetElem(L, i, &e)给一个位序
 LocateElem(L, e, compare())给一个值
 ListTraverse(l, visitt())最后一个引用性操作就是遍历
 {加工型操作}每一个操作的结果改变了整个结构
 ClearList(&L) 将L重置为空表
 PutElem(L, i, &e) 给元素赋值
 ListInsert(&L, i, e)在某个位置的元素之前插入一个新的元素，L的长度加1（改变了结构）
 ListDelete(&L, i, &e) 删除L第i个元素，并返回e，L的长度减1
 
 以上就是线性表的抽象数据类型，利用上述定义的线性表，可以完成其他更复杂的操作。 
 
 例1：求A并B 1，GetElem(LB,i)->e 2,LocateElem(LA, e, equal()) 3,ListInsert (LA, n+1, e)
 例2：非纯集合->构造纯集合 1,InistList(La) 2,GetElem(LB, i)->e 3,LocateElem(LA, e, equal) 4,listInsert(LA, n+1, e)也可以先排序后插入，算法策略不一样，时间复杂度也不一样。先排序后插入的效率为O(g(n))。所以有序和无序他的时间复杂度一般是差出量级的。一般用线性表表示集合的时候，一般讨论的是有序表（线性表中的数据元素是从小到大或者从大到小的顺序排序的）。
 例3：归并
都是单循环的算法的时间复杂度一般都是线性的。

### 2.2 线性表类型的实现--顺序映像，俗称顺序表
数据结构的存储结构可以有两种映像方法：顺序映像，链式映像
顺序映像：用一组地址连续的存储单元，依次存放线性表中的数据元素
线性表的起始地址，称作线性表的基地址。整个线性表可以用第一个元素的存储地址来表示。
 线性表的初始化操作 Status InitList_Sq(SqList& L)
线性表的操作
  LocateElem(L, e, compare())
  ListInsert(&L, i, e)
  ListDelete(&L, i, &e)  
顺序表优点，可以对每个数据元素进行随机存取，表长是显值
顺序表缺点，插入和删除元素需要移动元素
 
### 2.3 线性表类型的实现--链式映像，一般形式是单链表，也叫线性链表
用一组地址任意的存储单元存储线性表中的数据元素
以元素（数据元素的映像，数据域）+ 指针（指示后继元素存储位置的，指针域）=结点（表示数据元素）
以“结点的序列”表示线性表--称作链表
以线性表中第一个数据元素的存储地址作为线性表的地址，称作线性表的头指针（也可以加一个头结点，头结点数据元素部分无意义，这时候头指针就指向头结点）

单链表操作的实现
GetElem(L, i, &e) 单链表并不是随机存储的。基本操作为：使指针P始终指向线性表中的第J个数据元素，当P指向第I个数据元素是，取结点的数据域部分。时间复杂度O(ListLength(L))
ListInsert(&L, i, e) 基本操作为：找到线性表中第i-1个结点，修改其指向后继的指针。时间复杂度同上。
ListDelete(&L, i, &e) 基本操作为：找到线性表中第i-q个结点，修改其指向后继的指针。时间复杂度同上
CreateList_L(LinkList &L, int n) 依次在表头插入元素。时间复杂度同上

如果要用线性表来表示集合的时候，尽量先对它进行排序，用有序表来表示集合比用无序表来表示集合要好

用上述定义的单链表实现线性表的操作时，存在的问题：
1，单链表的表长是一个隐含值；
2，在单链表的最后一个元素最后插入元素时，需遍历整个链表；
3，在链表中，元素的“位序”概念淡化，结点的“位置”概念强化。
改进链表的设置：
1，增加“表长”，“表尾指针”和“当前位置的指针”三个数据域；
2，将其基本操作由“位序”，改为“指针”；
链表的基本操作：
Status InitLIst(LinkList &L);结构的初始化，构造一个空的线性链表L，头指针、尾指针和当前指针均指向头结点，表长为0；
Status DestroyList(LinkList &l);结构的销毁，遍历表，释放所有结点空间
引用型操作
Status ListEmpty(LinkList L);判表空
int ListLength(LinkList L);求表长
Status Prior(LinkList L);改变当前指针指向其前驱
Status Next(LinkList L);改变当前指针指向其后继
ElemType GetCurElem(LinkList L);返回当前指针所指数据元素
Status LocatePos(LinkList L, int i);改变当前指针指向第i个结点
Status LocateElem(LinkList L, ElemType e, Status(*compare)(ElemType, Elemtype))求满足判定关系的特定元素
Status ListTraverse(LinkList L, Status(*visit)())遍历整个线性表
加工型操作
Status ClearList(LinkList &L);重置为空表
Status SetCurElem(LinkList &l, ElemType e)更新当前指针所指的数据元素
Status Append(LinkList &L, Link s);在最后一个结点之后，链接一串结点
Status InsAfter(LinkList &L, ElemType e);将元素e插入在当前指针之后
Status DelAfter(LinkList &L, ElemType *e);删除当前指针之后的结点
利用上述定义的线性链表可以完成线性表的其他操作

其他形式的链表
1、双向链表 结点的结构出了有指向后继元素的指针以外还设计了一个指向前驱结点的指针
2、循环链表 最后一个结点的指针域的指针又指回第一个结点的链表

### 2.4 一元多项式的表示（线性表的应用）
pn(x)= p0 + p1x + p2x2 + ... + pnxn
在计算机中，可以用一个线性表来表示（只需要存放一元多项式的每一项的系数，但是有很多系数是0是就不太合理了）
一般情况下的一元多项式可写成
pn(x)=p1xe1 + p2xe2 + ... + pmXem
其中：pi是指数为ei的项的非零系数
（（p1, e1）, (p2, e2), ... , (pm, em)）
抽象数据类型一元多项式的定义如下：
ADT Polynomal {
 数据对象： 每个数据元素包含一个表示系数的实数和表示指数的整数
 数据关系：ai-1的指数一定是小于ai中指数的值的
基本操作：
CreatPolyn(&p, m) 操作结果：输入m项的系数和指数，建立一元多项式P。
DstroyuPolyn(&P) 初始条件：一元多项式P已存在。操作结果：销毁一元多项式P。
PrintPolyn(&p) 操作结果：打印输出一元多项式P。
AddPolyn(&Pa, &Pb) 操作结果：完成多项式相加运算，并销毁一元多项式Pb.
SubtractPolyn(&Pa, &Pb) 完成多项式相减运算，并销毁一元多项式Pb.
MultiplyPolyn(&Pa, &Pb) 操作结果：完成多项式相乘运算，并销毁一元多项式Pb
PolynLength(P) 操作结果：返回一元多项式P中的项数。
} ADT Polynomial
如此定义的多项式可以看成是一个有序表（对其数据元素而言），则多项式定义中的各个操作均可利用有序表的操作来完成。

抽象数据类型Polynomial的实现
typedef struct {
 float coef; //系数
 int expn; //指数
}term, ElemType;
//两个类型名：term用于本ADT， ElemType为LinkList的数据对象名

typedef LinkList polynomial; //用带表头节点的有序链表表示多项式

如果表的结构关系变化不大就用顺序表，经常变化就用链表


## 第三章 栈和队列
两种线性结构，栈和队列。从数据结构的角度来说栈和队列和线性表是一样的，不同的是从类型的角度（操作不一样）来说不同。

### 3.1 栈的类型定义
约定an端为栈顶， a1端为栈底。栈只能在栈顶插入元素，不能再其他位置插入。删除也只能在栈顶。只允许在表尾进行插入删除操作。后进先出
对队列来说插入和栈一样，删除每次都删除第一个元素。是一个单通道。先进先出

栈的基本操作：
InitStack(&S) 构造一个空栈S
DestroyStack(&S) 栈S被销毁
StackEmpty(S) 栈判空
StackLength(S) 求栈的长度，也就是元素个数
GetTop(S, &e) 取得栈顶元素，末尾
ClearStack(&s) 将S置为空栈
Push(&S, e) 压栈，入栈
Pop(&S, &e) 出栈

### 3.2 栈的应用举例
例一、数制转换 符合后进先出特点

例二、括号匹配的检验 检验括号是否匹配的方法用“期待的急迫程度”这个概念来描述 后出现的坐括号要先匹配。可能出现的不匹配的情况：到来的左括弧不是所“期待”的；到来的是“不速之客”；知道结束，也没有到来所“期待”的。
例三、行编辑程序问题 

例四、迷宫求解 通常用的是“穷举求解”的方法。算法的基本思想：若当前位置“可通”，则纳入路径，继续前进；若当前位置“不可通”，则后退，换向探索；若四周均“不可通”，则从路径中删除。
求迷宫中一条从入口到出口的路径的算法：
设定当前位置的初值为入口位置；
do {
 若当前位置可通，
 则 {
  将当前位置插入栈顶；
  若该位置是出口位置，则结束；
  否则切换当前位置的东临方块为新的当前位置；
}
 否则{
   若栈顶位置尚有其它方向未被探索，则设定新的当前位置为：沿顺时针方向旋转找到的栈顶位置的下一相邻块；
   若栈顶位置的四周均不可通，
   则 {
    删去栈顶位置；
}
}
} while (栈不空)

例五、表达式求值 限于二元运算符的表达式定义：表达式：：=（操作数）+（运算符）+（操作数） 操作数：：=简单变量|表达式  简单标量：：=标识符|无符号整数
因为后缀式的运算符顺序恰好为表达式的运算顺序，所以计算机编译器一般先把表达式转化为后缀式，再求值。用后缀式求值：先找运算符，再找操作数。如何从表达式得到后缀式？操作符后进先出。每个运算符的运算次序要由它之后的一个运算符来定，在后缀式中，优先数高的运算符领先于优先数低的运算符。1）设立运算符栈；2）设表达式的结束符为“#”，预设运算符栈的栈底为“#”（为了第一个运算符有比较）；3）若当前字符是操作数，则直接发送给后缀式；4）若当前运算符的优先数高于栈顶运算符，则入栈；5）否则，退出栈顶运算符发送给后缀式；6）“（”对它之前的运算符起隔离作用，“）”可视为自相应左括弧开始的表达式的结束符。

例六、实现递归（计算要实现递归，栈是不可缺少的）  当在一个函数的运行期间调用另一个函数时，在运行该被调用函数之前，需先完成三件事：将所有的实在参数、返回地址等信息传递给被调用函数保存；为被调用函数的局部变量分配存储区；将控制转移到被调用函数的入口。从被调用函数返回调用函数之前，应该完成：保存被调用函数的计算结果；释放被调用函数的数据区；依照被调用函数保存的返回地址将控制转移到调用函数。多个函数嵌套调用的规则是：后调用先返回此时的内存管理实行“栈式管理”。递归过程指向过程中占用的数据区，称之为递归工作栈；每一层的递归参数合成一个记录，称之为递归工作记录；栈顶记录指示当前层的执行情况，称之为当前活动记录；栈顶指针，称之为当前环境指针。汉诺塔。

### 3.3 栈类型的实现
顺序栈 类似于线性表的顺序映像实现，指向表尾的指针可以作为栈顶指针。
链栈 链栈的指针方向和线性表的相反。

### 3.4 队列的类型定义
栈和队列都是线性表，从结构上来说跟线性表都是一样的。所以他们的数据对象和数据关系的描述和线性表都是一样的，就是元素之间存在一个次序关系。只是对于队列来说有一个约定，a1端为队列头，an端为队列的尾。
和栈的基本操作对应，队列也有一些基本操作：
InitQueue(&Q) 初始化队列 
DstroyQueue(&Q) 销毁队列
QueueEmpty(Q) 判队列空
QueueLength(Q) 求得队列长度
GetHead(Q, &e) 用e返回Q的队头元素，队列元素并不会被删除。引用型操作ClearQueue(&Q) 队列置空。
EnQueue(&Q, e) 插入元素e为Q的新的队尾元素。入队列
DeQueue(&Q, &e) 删除Q的队头元素，并用e返回其值。加工型操作，出队列

### 3.5 队列类型的实现
链队列——链式映像
初始化：队列头Q.front和队列尾Q.rear均指向头结点。队列头总是指向头结点，而不是指向队列头元素。
入队列：在队尾插入一个新的节点。
出队列：修改的是头结点指向元素的指针，队列头指针始终不变。

循环队列——顺序映像
空间是一定的，初始化之后不能再分配。
设计到现实世界的仿真问题的话，排队的问题都要用到队列。

## 第四章、串
### 4.1 串的抽象数据类型的定义
串是把数据元素限定为字符的线性表。串的元素之间也存在一个次序关系。
基本操作：StrAssign(&T.chars) 串的赋值，chars是字符串常量，把chars赋为T的值
StrCompare(S, T) 串的比较。按字典次序比较。
StrCopy(&T, S) 串的赋值，由串S复制得串T。
StrLength(S) 串的长度，字符序列里字符的个数。
DestroyString(&S) 串销毁
Concat(&T, S1, S2) 串的联接。
StrEmpty(S) 判空串
SubString(&Sub, S, pos, len) 求子串的操作。子串是主串（字符序列）中的一个子序列（连续的）
Index(S, T, pos) 子串的定位函数。
Replace(&S, T, V) 串的置换。用V替换主串S中出现的所有与T相等的不重叠的子串。
StrInsert(&S, pos, T) 在串S的第pos个字符之前插入串T。
ClearString(&S) 清空串
StrDelete(&S. pos, len) 从 串S中删除第pos个字符起长度为len的子串。

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象的约束为字符集。然而串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象。而在串的基本操作中，通常以“串的整体”作为操作对象。

### 4.2 串的表示和实现
如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。
串可以有三种表示方法，也就是有三种存储映像。前二个是顺序映像，第三个为链式映像。
一、串的定长顺序存储表示（静态）
串的实际长度可在这个预定义长度的范围内随意设定，超过预定义长度的串值则被舍去，称之为“截断”。

二、串的堆分配存储表示（动态）
通常，C语言中提供的串类型就是以这种存储方式实现的。系统利用函数malloc()和free()进行串值空间的动态管理，为每一个新产生的串分配一个存储区，称串值共享的存储空间为“堆”。C语言中的串以一个空字符为结束符，串长是一个隐含的值。
这类串操作的实现算法为：先为新生成的串分配一个存储空间，然后进行串值的赋值。

三、串的块链存储表示
存储密度=数据元素所占空间/结点所占总空间
串值也可用链表来存储， 由于串的数据元素是一个字符，他只有8位二进制数，因此用链表存储时，通常一个结点中存放的不是一个字符，而是一个子串，例如：在编辑系统中，整个文件编辑区可以看成是一个串，每一行是一个子串，构成一个结点。即：同一行的串用定长结构（80个字符），行和行之间用指针相联接。

### 4.3 串的模式匹配算法（子串定位，就是在文本串里查找一个特定的字符串）
这是串的一种重要操作，很多软件，若有“编辑”菜单项的话，则其中必有“查找”子菜单项。
串匹配（查找）的定义： Index(S, T, pos) S为主串，T为模式串
下面讨论以定长顺序结构表示串时的几种算法。 
一、简单算法
依次比较每一个字符。
时间复杂度我O(strlen(S)*strlen(T))

二、首尾匹配算法
先比较模式串的第一个字符，再比较模式串的最后一个字符，最后比较模式串中从第二个到底n-1个字符。
时间复杂度同上。

三、KMP算法
KMP算法的时间复杂度可以达到O(m+n),它解决了上述两个算法中最大的问题，指针回朔问题。


## 第五章 数组和广义表 （广义表以后再做讨论）
### 5.1 数组的类型定义
数组也是一种线性结构
n维数据的类型定义
基本操作
InitArray(&A, n, bound1, ..., boundn)
DstroyArray(&A)
Value(A, &e, index1, ..., indexn)
Assign(&A, e, index1, .., indexn)
数组只有这4个基本操作，跟别的线性结构有很大的不同，没有加工型操作（改变结构）。

### 5.2 数组的顺序表示和实现
数组只有一种存储结构，顺序表示。因为没有改变结构的加工型操作。
数组的类型特点：
1）只有引用型操作，没有加工型操作；
2）数组是多维的结构，而存储空间是一个一维的结构。
有两种顺序映像的方法：
1）以行序为主序（低下标优先变化）；
2）以列序为主序（高下标优先变化）；

“行序为主序”的地址计算公式(大多数语言是以行序为主序的，除了fortun语言外)
二维数组A中任一元素ai,j的存储位置
LOC[i, j] = LOC[0, 0] + (b2 * i + j)L
这个是2维数组的映像函数，数组元素的存储位置是其下标的线性函数。随机存储的结构。

### 5.3 稀疏矩阵的压缩存储
假设m行n列的矩阵含t个非零元素，则称 delta= t/(m*n)为稀疏因子。通常认为delta<=0.05的矩阵为稀疏矩阵。

以常规方法，即以二维数组表示高阶的稀疏矩阵时产生的问题：
1）零值元素占的空间大；
2）计算中进行了很多和零值的运算；

解决问题的原则：
1)尽可能少存或不存零值元素；
2）尽可能减少没有实际意义的运算；
3）运算方便；即：能尽可能快的找到与下标值（i,j）对应的元素；能尽可能快地找到同一行或同一列的非零值元；

1）特殊矩阵的压缩存储 例如：三角矩阵 对角矩阵
2）随机稀疏矩阵的压缩存储 随机矩阵中的非零元分布不规则
三种常用的解决方案（表示方法）：前两种为顺序存储
一、三元组顺序表（和多项式的表示类似）
三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。然而，若需随机存取某一行中的非零元，则需从头开始进行查找。
二、行逻辑联接的顺序表
修改前述的稀疏矩阵的结构定义，增加一个数据成员rpos，其值在稀疏矩阵的初始化函数中确定。
三、十字链表(非零元个数有变化的时候比较方便，如矩阵相加)

### 5.4 广义表的类型定义
广义表也是特殊的线性结构。
广义表是递归定义的线性结构。因为它在定义的时候用到了自己，广义表的数据对象可以是广义表。
一般情况下，广义表写成LS = (α1，α2，...,αn）（线性序列）其中：αi或为原子或为广义表。(线性表用的是a1,a2，广义表用的是α)
广义表是一个多层次的线性结构（因为是递归的，和树有类似的地方，是一个多层次的线性结构）。

广义表的结构特点：
1）广义表中的数据元素有相对的次序（因为它是一个线性结构）；
2）广义表的长度定义为最外层包含元素的个数。
3）广义表的深度定义为所含括弧的重数；“原子”的深度为“0”；“空表”的深度为1（长度为0）；
4）广义表可以共享；
5）广义表可以是一个递归的表；递归表的深度是无穷值，长度是有限值；
6）任何一个非空广义表均可分解为表头（第一项）和表尾（去掉第一项的剩余部分）两部分。表头可以是原子或者广义表，表尾一定是一个广义表。

基本操作
结构的创建和销毁：InitGList(&L);DestroyGList(&L);CreateGList(&L,S);CopyGList(&T,L);
状态函数：GListLength(L);GListDepth(L);GListEmpty(L);GetHead(L);GetTail(L):
插入和删除操作：InertFirst_GL(&L,e);DeleteFirst_GL(&L,&e);
遍历：Traverse_GL(L,Visit());

以上就是广义表的类型定义。

### 5.5 广义表的表示方法
广义表不会有顺序存储结构，只有链式存储结构。
头、尾指针的链表结构
因为广义表每个数据元素既可能是一个原子也可能是一个广义表，所以广义表的链表结构有两种结点。原子结点，表结点。

构造存储结构的两种分析方法：
1）空表 ls=NIL 非空表一定有一个表头指针指向广义表结点。
2）广义表可以看成是由多个子表构成的。用线性链表表示。

### 5.6 广义表操作的递归函数
广义表跟树和图一样是一个递归定义的结构。操作可以递归的写。

递归函数
一个含直接或间接调用本函数语句的函数被称之为递归函数，它必须满足一下两个条件：
1）在每次调用自己时，必须是（在某种程度上）更接近于解（收敛的，不是发散的）
2）必须有一个终止处理或计算的准则。

梵塔的递归函数
void hanoi (int n, char x, char y, char z)
{
  if (n==1)
     move(x,1,z);
   else {
    hanoi(n-1,x,z,y);
    move(x,n,z);
    hanoi(n-1,y,x,z);
}
}
递归的规模越来越小(n-1),有递归的终止准则（n==1），所以是递归函数。

这一类递归函数，可以借助算法设计的一种方法--分治法（分割求解）来求解。
分治法的设计思想为：对于一个输入规模为n的函数或问题，用某种方法把输入分割成k(1<k<=n)个子集，从而产生l个子问题，分别求解这l个问题，得出l个问题的子解，再用某种方法把他们组合成原来问题的解。若子问题还相当大，则可以反复使用分治法，直至最后所分得的子问题足够小，以至可以直接求解为止。

在利用分治法求解时，所得子问题的类型常常和原问题相同，因而很自然地导致递归求解。
在用分治法求解问题时，如果子问题和原问题有同样的性质，只是规模更小，我们可以递归的解。

广义表从结构上可以分解成：
广义表=表头+表尾 或者 广义表=子表1+子表2+...+子表n
因此常利用分治法求解（可以分成多个子问题）。

求广义表的深度
广义表的深度=Max{子表的深度} + 1 
空表的深度 = 1，原子的深度 = 0；

复制广义表
若ls=NIL 则 newls=NIL	
否则，有表头ls^.hp复制得newhp，由表尾ls^.tp复制得newtp。构造结点newls,并使newls^.hp = newhp, newls^.tp=newtp

创建广义表的存储结构
可以按照不同的输入形式来做。
根据LS = '(α1，α2，...,αn）'建广义表ls
若LS='()' 则 ls=NIL
否则，构造表结点ls^，分解出第一个子串α1，对应建广义表的表头ls^.hp。
若剩余串非空，则构造表尾结点ls^.tp分解出第二个子串α2，对应建广义表...以此类推，直至剩余串为空串止。
跟第二种一样，都是创建存储结构。只是两种不同的分析方法。不管哪种分析方法把递归函数的定义在逻辑上分析清楚了，算法自然就有了

从另外一个角度看，广义表是一个广义的线性表，因此他的操作跟线性表是非常类似的。所以有些操作可以根据线性表的分析拓展过去。

删除单链表中所有值为x的数据元素（从这个算法我们可以得到广义表的相应算法）
从另一个角度看，线性链表既是一种顺序结构，也是一种递归的结构。

删除广义表中所有元素为x的原子结点
分析：广义表和线性表比较：相似处：都是顺序结构。不同处：广义表的数据元素可能还是个广义表；删除时，不仅要删除原子结点，还需要删除相应的表结点。

递归函数一定有一个递归的基：整个递归到头，不再往下递归的情况。有一个递归的组合项：所有递归的解求到了怎么得到整个函数的解。

递归函数综合几点：
1、对于含有递归特性的问题，最好设计递归形式的算法。但也不要单纯追求形式，应在算法设计的分析过程中“就事论事”。例如，在利用分割求解设计算法时，子问题和原问题的性质相同；或者，问题的当前一步解决之后，余下的问题和原问题的性质相同，则自然导致递归求解。注意递归的基和递归的参数。
2、实现递归函数，目前必须利用“栈”。一个递归函数必定能改写为利用栈实现的非递归函数；反之，一个用栈实现的非递归函数可以改写为递归函数。需要注意的是递归函数递归层次的深度决定所需存储量的大小。
3、分析递归算法的工具是递归树，从递归树上可以得到递归函数的各种相关信息。例如：递归树的深度即为递归函数的递归深度；递归树上的结点数目恰为函数中的主要操作重复进行的次数；若递归树蜕化为单支树（求阶乘）或者递归树中含有很多相同的结点（计算斐波那契数列），则表明该递归函数不适用。

递归次序正好是递归树的中序遍历。
递归深度涉及所需要的存储量的信息。
如果递归树是单支树，就没必要写成递归。应该用递推的方法，从下往上，或者从后往前的分析。递归是从顶往下的分析。

4、递归函数中的尾递归容易消除。在函数出口之前的递归函数语句叫做尾递归。设置循环可以消除尾递归。
5、可以用递归方程来表述递归函数的时间性能。
递归函数的设计方法还有回朔法等。

## 第六章：树和二叉树
### 6.1 树的类型定义
数据对象D：
D是具有相同特性的数据元素的集合。
数据关系R：
若D为空集，则称为空树；
否则：
（1）在D中存在唯一的称为根的数据元素root；
（2）当n>1时，其余结点可分为m(m>0)个互不相交的有限级T1,T2, ..., Tm，其中每一棵子集本身又是一棵符合本定义的树，称为根root的子树。
一般画树我们不画箭头，但是我们讨论的是有向树（有前趋后继的关系）。

树是一种层次结构

基本操作：
结点：数据元素+若干指向子树的分支（树的基本单位）
结点的度：分支的个数
树的度：树中所有结点的度的最大值
叶子结点：度为零的结点
分支结点：度大于零的结点
从根到结点的路径：由从根到该结点所经过分支和结点构成

孩子结点、双亲结点、兄弟结点、祖先结点、子孙结点（和族谱类似）

结点的层次（树是一个层次的关系（结构））：假设根节点的层次为1,第l层的结点的子树根节点的层次为l+1。
树的深度：树中叶子结点所在的最大层次

森林：是m(m>=0)棵互不相交的树的集合
任何一棵非空树是一个二元组Tree = (root, F)。其中root被称为根节点，f被称为子树森林

基本操作（比较多，分三大类讨论）：
查找(特定的查找和按关系的查找，还有树的特性相关的一些操作)
Root(T)查树的根; Value(T, cur_e)找树上某个值的结点; Parent(T, cur_e)找双亲;
LeftChild(T, cur_e)找左孩子结点;RightSibling(T, cur_e)找右兄弟结点;TreeEmpty(T)判树空;TreeDepth(T)求树的深度;TraverseTree(T, Visit())树的遍历;

插入
InitTree(&T)初始化，建一棵空树;CreateTree(&T, definition)根据定义建一棵树；
Assign(T, cur_e, value)改变树上某个结点的值;InsertChild(&t, &p, i ,c)插入一棵子树；

删除
ClearTree(&T)树的清空；DestroyTree(&T)结构销毁；DeleteChild(&T, &p, i)删除某个结点的某个子树;

我们讨论树是有向树：
1）有确定的根；
2）树根和子树根之间为有向关系（前趋后继的关系）

有序树和无序树的区别在于：子树之间是否存在次序关系。通常讨论的是无序树，主要描述的是层次的关系，同层来说一般不讲究次序。

和线性结构的比较：1对1,1对多

### 6.2 二叉树的类型定义（树的结构通常转化为二叉树去讨论）
二叉树或为空树；或是由一个根节点加上两棵分别成为左子树或右子树的、互不相交的二叉树组成。
二叉树有五种基本形态。二叉树并不是有序树，两种树不同。
二叉树的主要基本操作：（跟树一样分三大类）
查找
Root(T);Value(T, e);Parent(T,e);LeftChild(T,e); RightChild(T,e);LeftSibling(T,e);RightSibling(T,e);BiTreeEmpty(T);BiTreeDepth(T);PreOrderTraverse(T, Visit()); InOrderTraverse(T, Visit());PostOrderTraverse(T, Visit());LevelOrderTraverse(T, visit());
插入
InitBiTree(&T);初始化
Assign(T, &e, value);赋值
CreateBiTree(&T, definition);根据定义构造一棵二叉树
InsertChild(T, p, LR, c);在某个结点上插入一棵以C为根节点的二叉树
删除
ClearBiTree(&T);
DestroyBiTree(&T);
DeleteChild(T,p, LR);删除某个结点的子树
对树的操作一般不是删除某一个结点，而是删除某一棵子树，否则没有太大意义。

二叉树的重要特性：
性质1：在二叉树的第i层上之多有2(i-1)次方个结点（i>=1）
性质2：深度为k的二叉树上之多含2K次方-1个结点（k>=1）.根据性质一得到
性质3：对任何一棵二叉树，若他含有n0个叶子结点，n2个度为2的结点，则比存在式:n0 = n2 +1

两种特殊的二叉树：
满二叉树：指的是深度为k且含有2k次方-1个结点的二叉树
完全二叉树：树中所含的n个结点和满二叉树中编号为1至n的结点一一对应

性质4：具有n个结点的完全二叉树的深度为log2n（取下整） + 1
性质5：若对含n个结点的二叉树从上到下且从左到右进行1至n的编号，则对二叉树中任一一个编号为i的结点：
（1）若i=1,则该结点时二叉树的根，无双亲结点，否则，编号为i/2取下整的结点为其双亲结点
（2）若2i>n,则该结点无左孩子，否则，编号为2i的结点为其左孩子结点；
（3）若2i+1>n,则该结点无右孩子结点，否则，编号为2i+1的结点为其右孩子结点。

### 6.3 二叉树的存储结构
一、二叉树的顺序存储表示
为了表示二叉树的左右子树的关系，每个结点不是挨着存储，我们必须按照他们和满二叉树之间的关系，按照编号来存储到相应的数组分量中。因此这种存储方式，只适用于完全二叉树，对于任意二叉树为了把左右子树关系表示出来会浪费很多空间，因此对于任意二叉树一般不使用这种方法。

二、二叉树的链式存储表示
链式存储结点的指针个数不同可以有多种不同的存储方法。
1、二叉链表（每个结点里含有2个指针域，一个数据域）
2、三叉链表（多加了一个指针域，指向它的双亲，根节点的双亲是空的）
3、双亲链表（每个结点包含一个双亲指针，一个左右孩子标志域和一个数据域）
双亲链表的所有结点放在一个数组里面，给出结点数目和根节点位置。因为只包含双亲指针，所以结点是孤立的、分散的，所以我们需要把所有结点合起来放在一个一维数组里面。
4、线索链表（后面讲了线索再来讨论）

### 6.4 二叉树的遍历
一、问题的提出
遍历：顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。
“访问”的含义可以很广，如：输出结点的信息、对结点赋值等。
“遍历”是任何结构类型均有的操作，对线性结构而言，只有一条搜索路径（因为每个结点均只有一个后继），故不需要另加讨论。而二叉树是非线性结构，每个结点有两个后继，则存在如何遍历即按什么样的搜索路径遍历的问题。

对“二叉树”而言，可以有三条搜索路径：
1、先上后下的按层次遍历；
2、先左（子树）后右（子树）的遍历；
3、先右后左的遍历；
2和3这两条搜索路径是相反，完全对称的，所以只要讨论其中一条搜索路径就可以了

二、先左后右的遍历算法的定义
先（根）序的遍历算法
若二叉树为空树，则空操作；否则，
（1）访问根结点；
（2）先序遍历左子树；
（3）先序遍历右子树；

中（根）序的遍历算法
若二叉树为空树，则空操作；否则，
（1）中序遍历左子树；
（2）访问根根结点；
（3）中序遍历右子树。

后（根）序的遍历算法
若二叉树为空树，则空操作；否则，
（1）后序遍历左子树；
（2）后序遍历右子树；
（3）访问根结点。

三、算法的递归描述（用二叉链表描述）
void Preorder(BiTree T, void(*visit)(TElemType &e))
{
 if(T){
 Visit(T->data);
 Preorder(T->lchild, visit);
 Preorder(T->rchild, visit);
}
}

四、中序遍历算法的非递归描述（递归转非递归要用到栈）
void Inorder (BiTree T, void (*visit)(TelemType &e))
{
 Stack *s;
 t = GoFarLeft(T, S0);
 while(t)
 {
 visit(t->data);
 if (t->rchild)
  t = GoFarLeft(t->rchild, S);
 else if (!StackEmpty(S))
  t= Pop(S);
 else t = NULL;
}
}

五、遍历算法的应用举例：
遍历算法是二叉树的各种操作的核心，很多操作可以在遍历算法的基础上完成。
1、统计二叉树中叶子结点的个数（先序遍历）
void CountLeaf(BiTree T, int& count)
{
 if (T) 
 {
   if ((!T->lchild) &&（!T->rchild))
         count++;
   CountLeaf(T->lchild,count);
   CountLeaf(T->rchild, count);
}
}

2、求二叉树的深度（后序遍历）
int Depth(BiTree T)
{
 if(!T)
    depthval = 0;
 else
 {
  depthLeft = Depth(T->lchild);
  depthRight = Depth(T->rchild);
  depthval = 1 + (depthLeft>depthRight?depthLeft:depthRight);
}return depthval;
}
二叉树的很多操作可以在递归定义的基础上，利用遍历来完成，但是用什么遍历看问题的具体不同而不同。能用先序遍历就尽量用先序遍历。

3、复制二叉树（后序遍历）
BiTNode *GetTreeNode(TElemType item, BiTNode *lptr, BiTNode *rptr)
{
  if(!(T-(BiTNode*)malloc(sizeof(BiTNode))))
   exit(1);
 T->data = item;
 T->lchild = lptr;
 T->rchild = rptr;
 return T;
}

BiTNode *CopyTree(BiTNode *T)
{
 if (!T)
   return NULL;
 if(T->lchild)
  newlptr = CopyTree(T->lchild);
 else newlptr = NULL:
 if (T->rchild)
  newrptr = CopyTree(T->rchild);
 else newrptr = NULL;
 newnode = GetTreeNode(T->data, newlptr, newrptr);
 return newnode;
}

4、建立二叉树的存储结构（一般来说就是建立一个二叉树的二叉链表）
按给定的先序序列(包括空字符)建立二叉链表
Status CreateBiTree(BiTree &T)
{
 scanf(&ch);
 if (ch=='') T = NULL;
 else
 {
  if (!(T = (BiTNode *)malloc*sizeof*BiTNode))))
   exit(OVERFLOW);
  T->data = ch;
  CreateBiTree(T->lchild);
  CreateBiTree(T->rchild);
}
return OK;
}
按给定的表达式建相应二叉树
由先缀表示式建树（对二叉树进行先序遍历得到先缀表达式，反之是后缀）

根据先序和后序序列建树
先序序列和后序序列可以唯一确定一棵二叉树。

### 6.5 线索二叉树
一、可谓线索二叉树
把遍历里的前趋后继关系保存起来得到的二叉树
遍历也可以看成是对二叉树的线性化操作
遍历二叉树的结果是，求得结点的一个线性序列
指向该线性序列中的前趋和后继的指针，称为“线索”
包含“线索”的存储结构，称作“线索链表”，与其相应的二叉树，称为“线索二叉树”
对线索链表中结点的约定：
在二叉链表的结点中增加两个标志域，并作如下规定：
若该结点的左子树不空，则lchild域的指针指向其左子树，且左标志域的值为0;否则，lchild域的指针指向其“前趋”且左标志的值为1。
若该结点的右子树不空，则rchild域的指针指向其右子树，且右标志域的值为“指针Link”；否则，rchild域的指针指向其“后继”，且右标志的值为“线索Thread”。

线索链表的结构描述（改写二叉链表的定义）：
typedef enum {Link, Thread} PointerThr,//Link==0:指针，Thread==1:线索

typedf struct BiThrNode{
 TElemType data;
 struck BiThrNode *lchild, *rchild;
 PointerThr LTag, RTag; //左右标志
}BiThrNode, *BiThrTree;

二、线索链表的遍历算法（线索链表的遍历不需要用到栈）
线索链表上我们有了所有遍历需要的信息，不需要用到栈，实际上一个for循环就可以完成
for (p = firstNode(T); p; p=Succ(P))
Visit(p);
线索链表遍历的关键是找第一个结点和每个结点的后继。

中序线索化链表的遍历算法：
中序线索链表用的比较多。后续线索链表建立比较麻烦。

三、如何建立线索链表
线索化的过程就是遍历的过程
在中序遍历过程中修改结点的左、右指针域，以保存当前访问结点的前趋和后继信息。遍历过程中，附设指针pre，并始终保持指针pre指向当前访问的、指针p所指结点的前趋。

遍历的算法在不同的存储结构里有不同的描述，但是定义都是一样的。

### 6.6 树和森林的表示方法
树的三种存储结构（我们讨论的是无序树）
一、双亲表示法：
每个结点由一个结点的数据域和结点的双亲两个域来表示
二、孩子链表表示法：
每一个结点有一个孩子域和指向一个孩子链表的结点的指针来表示。
三、树的二叉链表（孩子-兄弟）存储表示法
每个结点有两个指针。左指针指向第一个孩子结点，右指针指向兄弟结点。
树的操作，可以转换成二叉树的操作。

森林和二叉树的对应关系
由森林转换成二叉树的转换规则为：
若F = 空， 则B = 空；
否则，由ROOT(T1)对应得到Node(root);由（t11, t12,...,t1m)对应的到LBT;由(T2,T3,...,Tn)对应得到RBT。
由二叉树转换为森林的转换规则为：
若B = 空，则F = 空；
否则，由Node(root)对应得到ROOT(T1);由LBT对应得到（t11,t12,...,t1m)；由RBT对应得到（T2,T3,..,Tn)

由此，树的各种操作均可对应二叉树的操作来完成。
应当注意的是，和树对应的二叉树，其左、右子树的概念已改变为：左是孩子，右是兄弟

### 6.7 树和森林的遍历（树的主要操作）
树的遍历可有三条搜索路径：
先根（次序）遍历：
 若树不空，则先访问根结点，然后依次先根遍历各棵子树
后根（次序）遍历：
 若树不空，则先依次遍历各棵子树，然后访问根结点。
按层次遍历：
 若树不空，则自上而下自左至右访问树中每个结点。

森林由三部分构成：
1、森另中第一棵树的根结点；
2、森林中第一棵树的子树森林；
3、森林中其他树构成的森林。

森林的遍历
先序遍历（依次从左至右对森林中的每一棵树进行先根遍历）
中序遍历（依次从左至右对森林中的每一棵树进行后根遍历）

树的先根遍历对应二叉树的先序遍历
树的后根遍历对应二叉树的中序遍历
二叉树的后序遍历对于树和森林没有意义。

树遍历算法的应用
一、求树的深度的算法：
int TreeDepth(CSTree T)
{
 if(!T) return 0;
 else {
  h1 = TreeDepth(T->firstchild);
  h2 = TreeDepth(T->nextsibling);
  return(max(h1+1,h2));
}
}

二、输出树中所有从根到叶子的路径的算法：
写树的递归算法的时候，慎用循环。

三、建树的存储结构的算法：
按层次遍历，是一个先进先出的结构，需要用到队列
void CreatTree(CSTree &T)
{
 T = NULL;
 for (scanf(&fa,&ch);ch!='#';scanf(&fa,&ch);)
{
 p = GetTreeNode(ch);
 EnQueue(Q,p);
 if(fa=='#') T=p;
 else {
 GetHead(Q, s);
 while(s->data != fa){
 DeQueue(Q,s);GetHead(Q,s);
}
 if(!(s->firstchild))
  {s->firstchild = p; r=p;}
 else
  {r->nextsibling = p; r=p;}
}
}
}
树经常用的是二叉链表表示法。用二叉链表表示的时候树和森林都对应到一棵二叉树的关系，可以证明，这个时候空指针是最少的，对树来说需要的栈的存储空间也是最省的。

### 6.8 哈夫曼树与哈夫曼编码
最优树（哈夫曼树）的定义
结点的路径长度定义为：从根结点到该结点的路径上分支的数目。
树的路径长度定义为：树中每个结点的路径长度之和。
树的带权路径长度定义为：树中所有叶子结点的带权路径长度之和WPL(T)=sigemawklk(对所有叶子结点)

在所有含n个叶子结点，并带相同权值的m叉树中，必存在一棵其带权路径长度取最小值的数，称为“最优树”。

如何构造最优树
哈夫曼最早研究出一个带有一般规律的算法：
以二叉树为例：
（1）根据给定的n个权值{w1,w2,...,wn},构造n课二叉树的集合F={T1,T2,...,Tn}，其中每棵二叉树中均只含一个带权值的wi的根结点，其左、右子树为空树；
（2）在F中选取其根结点的权值为最小的两棵二叉树，分别作为左、右子树构造一，一棵新的二叉树，并置这棵二叉树根结点的权值为其左、右子树根结点的权值之和；
（3）从F中删去这两棵树，同时加入刚生成的新树；
（4）重复（2）和（3）两步，直至F中只含一棵树为止。
最优二叉树可以作为判定树的一种构造方法。

如何构造前缀编码
一般电文在传送的时候都是用0101编码的
编码一般分为两大类：
等长码 A00 B01 C10 D11 一般是概率相同时候使用，这时电文的总长度最短
不等长码 编码前提：任何一个码不能是另一个码的前缀 

前缀编码指的是，任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。由哈夫曼树的得到的哈夫曼编码是一种最优前缀编码。

正则二叉树：只有度为0或者度为2的结点的数。哈夫曼树就是一种正则二叉树。
完全二叉树用顺序存储结构，一般情况下用二叉链表

## 第七章：图
### 7.1 抽象数据类型图的定义 
每个抽象数据类型都是一个数据对象、数据关系和基本操作三元组定义的

若<v, w>∈VR,
则<v,w>表示从顶点v到顶点w的一条弧。称顶点v为弧尾，称顶点w为弧头。由顶点集和弧集构成的图称作有向图。
若<v,w>∈VR,必有<w,v>∈VR,则称（v,w)为顶点v和顶点w之间存在一条边。由顶点集和边集构成的图称作无向图。
弧或边带权的图分别称作有向网或无向网。

基本操作：
结构的建立和销毁
CreateGraph(&G,V,VR);DestroyGraph(&G);
插入或删除顶点
InsertVex(&G,v);DeleteVex(&G,v);
对顶点的访问操作
LocateVex(G,u);GetVex(G,v);PutVex(&G,v,value);
插入和删除弧
InsertArc(&G,v,w);DeleteArc(&G,v,w);
对邻接点的操作
FirstAdjVex(G,v);NextAdjVex(G,v,w)
遍历
DFSTraverse(G,v,Visit());BFSTraverse(G,v,Visit());

### 7.2 图的存储表示
二叉树的顺序结构只适用于完全二叉树，对图来说顺序结构也不适用。
所有存储结构，关键是怎么表示边的信息
一、图的数组（邻接矩阵）存储表示
用二维数组来存储图的邻接矩阵

二、图的邻接表的存储结构
和树的孩子链表表示法类似。每个结点包含顶点数据域、指向第一条依附该顶点的弧的指针域。所有顶点结点都存放在一个一维数组里面。

三、有向图的十字链表存储表示
十字链表表示图的邻接矩阵的信息。我们再邻接表里只表示了行的信息，在逆邻接表里只表示了列的信息。而十字链表把行和列的关系都表示了出来。

四、无向图的邻接多重表存储表示
和有向图的十字链表对应。十字链表把邻接表和逆邻接表上表示同一条弧的两个结点合在了一块。无向图是把邻接表中表示同一条边的两个结点合起来。

图的存储表示的边的表示都是一样的，要用到一个数组。不同的是边的关系的表示是不一样的。都是链式映像。

### 7.3 图的遍历
从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。
深度优先搜索
图的遍历可以从任意一个顶顶点出发，顶点的地位是相同的。
和树的先根遍历类似。不同的是图的子图是有可能相交的，需要检查邻接点是否已经被访问过。访问过的顶点需要做一个标识。
对图来说，我们一般不讨论空图。所以不需要判断图是否为空。
深度优先搜索遍历访问到的顶点和边构成的树叫做深度优先生成树。

广度优先搜索
广度优先搜索过程形成的树叫做广度优先生成树。从逻辑上访问次序是不唯一的，但是在计算机里，由于存储位置是确定的，因此访问的先后顺序也就确定了。按逻辑图画，每个人画的可以不一样，但是如果给出了存储结构，访问次序就一定了。

遍历的应用举例
和树一样，图的遍历也是一个通用的操作，图的其它操作可以在遍历的基础上完成。比如，生成生成树、求连通分量和求搜索路径等。
1、求一条从顶点i到顶点s的简单路径。
可以在深度优先搜索遍历的基础上完成。简单路径不能包含环。用递归完成。
2、求两个顶点之间的一条路径长度最短的路径。
基于广度优先搜索遍历，并修改链队列的结点结构及其入队列和出队列的算法。也可以用深度优先搜索遍历去做，找到所有顶点里面路径长度最短的路径。

### 7.4 最小生成树
普里姆算法
可取图中任意一个顶点v作为生成树的根，之后若要往生成树上添加顶点w，则在顶点v和顶点w之间必定存在一条边，并且该边的权值在所有连通顶点v和w之间的边中取值最小。
一般情况下，假设n个顶点分成两个集合：U(包含已落在生成树上的顶点）和V-U（尚未落在生成树上的顶点），则在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。

克鲁斯卡尔算法
为使生成树上边的权值之和最小，显然，其中没一条边的权值应该尽可能的小。克鲁斯卡尔算法的做法就是：先构造一个只含n个顶点的子图SG，然后从权值最小的边开始，若它的添加不使SG中产生回路，则在SG上加上这条边，如此重复，直至加上n-1条边为止。

由于普里姆算法的时间复杂度为O(n2),则适用于稠密图；而克鲁斯卡尔算法需对e条边按权值进行排序，其时间复杂度为O(eloge)，则适于稀疏图。

### 7.5 重（双）连通图和关节点
任何一个通信网或者运输网都应该是一个连通图（任意两个点之间有路径想通）。但是一个可靠的通信网光是一个连通图还是不够，我们希望通信网是非常可靠的，不管每个局部的断点出了问题的时候整个通信网不至于瘫痪。
从图的特性上来说，若从一个连通图中删去任何一个顶点及其相关联的边，它仍为一个连通图。这样的话，该连通图就被称为重（双）连通图。
若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为关节点。
没有关节点的连通图就是双连通图。

关节点的特征：
假设从某个顶点V0出发对连通图进行深度优先搜索遍历，则可得到一棵深度优先生成树，树上包含图的所有顶点。
若生成树的根结点，有两个或两个以上的分支，则此顶点（生成树的根）必为关节点；
对生成树上的任意一个“顶点”，若其某课子树的根或子树中的其他“顶点”没有和其祖先想通的回边，则该“顶点”必为关节点。

如何求关节点？
构建深度优先生成树。
在深度优先遍历基础上求得。
若不存在关节点则此连通图为双连通图。
若存在关节点，则这些关节点对应为通信网上的薄弱点，可考虑对薄弱点进行加强，防止薄弱点异常导致整个通信网瘫痪。从而增加通信网的可靠性。

### 7.6 两点之间的最短路径问题
从源点到其余各点的最短路径
算法的基本思想是：依路径长度递增的次序求得各条路径。

每一对顶点之间的最短路径
算法的基本思想是：从vi到vj的所有存在的路径中，选出一条长度最短的路径。

### 7.7 拓扑排序
假设以有向图表示一个工程的施工图或程序的数据流图（有先后次序问题），则图中不允许出现回路。
如何检查有向图中是否存在回路的方法之一，是对有向图进行拓扑排序。

拓扑排序就是对有向图进行如下操作：
按照有向图给出的次序关系，将图中顶点排成一个线性序列，对于有向图中没有限定次序关系的顶点，则可以认为的加上任意的次序关系。
由此所得顶点的线性序列称之为拓扑有序序列。

如何进行拓扑排序？
一、从有向图中选取一个没有前趋的顶点，并输出；
二、从有向图中删去此顶点以及所有以它为尾的弧；
重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。图为空，得到一个顶点的线性序列，说明这个有向图没有回路。
没有前途的顶点-->入度为零的顶点（定性概念-->定量概念）。
删除顶点及以它为尾的弧-->弧头顶点的入度-1。

### 7.8 关键路径
假设以有向网表示一个施工流图，弧上的权值表示完成该项子工程所需的时间，问：哪些子工程项是“关键工程”？即：将影响整个工程完成期限的子工程项。
整个工程完成的时间为：从有向图的源点到汇点的最长路径。
“关键活动”指的是：该弧上的权值增加将使有向图上的最长路径的长度增加。

如何求关键活动？
“事件（顶点）”的最早发生时间ve(j)=从源点到顶点j的最长路径长度；
“事件（顶点）”的最迟发生时间vl(k)=从顶点k到汇点的最短路径长度；
“活动（弧）”的最早开始时间ee(1)=ve(j);
“活动（弧）”的最迟开始时间el(i)=vl(k)-dut(<j,k>);

算法的实现要点：
显然，求ve的顺序应该是按拓扑有序的次序；而求vl的顺序应该是按拓扑逆序的次序；因为拓扑逆序序列即为拓扑有序序列的逆序列，因此应该在拓扑排序的过程中，另设一个“栈”记下拓扑有序序列。

遍历是所有非线性结构的操作基础，包括二叉树，树，图。广义表虽然是线性结构但是它和树也有一些类似的地方。
不同的应用需要应用不同的搜索路径
1、深度优先搜索遍历
2、广度优先搜索遍历

深度优先搜索遍历：
二叉树 先序、中序、后序
树 先根、后根
图 先访问顶点、后访问顶点（对图来说一般来说用先访问顶点）
广义表 先遍历表头、先遍历表尾（广义表的很多操作实际上是一个遍历）

深度优先搜索遍历算法的两种形式（实际上就是递归形式的）：
递归
非递归（需要用到“栈”来保留一些信息）用非递归要分析清楚，用栈做什么， 保留什么信息。
例如：遍历二叉树时，需要利用栈保留曾经路过的根结点（中序）；或者保留尚未遍历的右子树的根结点（先序）以便左子树返回时继续遍历右子树；
后序遍历二叉树的情况要复杂一些，由于根结点的访问在左、右子树的遍历之后，则不仅要保存结点的信息，还应保存“标志”。
反之，如果在存储结构中加上适当信息，则不需要用到栈，只要用递推就可以了额。
比如：在二叉链表的结点中增设两个域：双亲域，标志域。
深度优先遍历图也可以有非递归的形式，栈中保留的信息应该是，当前访问的顶点和他当前的邻接点。

广度优先搜索遍历，实际上就只有一个框架，需要用到队列。

## 第九章 查找表
整个数据结构是两大部分，前面是基本的数据结构，线性结构和非线性结构看，还有一类是特殊的既是线性结构也带层次的。对基本数据结构需要掌握结构的特性，存储结构的表示，以及在存储结构上基本操作的进行，在这基础上可以扩展到他们的应用。后面主要要讨论的是查找和排序，排序是为查找服务的。
查找这一章主要是讨论集合（第四类数据结构），数据库中的表实际上就是一个集合，它们中的数据元素有最简单的关系：从属于同一个集合。

查找表是由同一类型的数据元素（或记录）构成的集合（和数学上的集合该娘相同）。
查找表实际上在日常生活中和计算中都是用的最多的。一个学生从入学到毕业要填很多表，而在计算机中管理最多的数据库，管理的也是这些表。表是自然形成的，没有存在必然的前趋后继关系。

对查找表经常进行的操作：
1）查询某个“特定的”数据元素是否在查找表中；
2）检索某个“特定的”数据元素的各种属性；
3）在查找表中插入一个数据元素；
4）从查找表中删去某个数据元素。
检索和查询不一样，检索已经知道了在集合里面有这个数据元素，我们需要知道它的其他属性。

根据查找表的操作不同，我们可以分为两类：
静态查找表：仅作查询和检索操作的查找表
动态查找表：有时在查询之后，还需要将“查询”结果为“不在查找表中？：的数据元素插入查找表；或者，从查找表中删除其“查询”结果为“在查找表中”的数据元素。这些操作都是在查询的基础上完成的。

查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录。
关键字：是数据元素（或记录）中某个数据项（数据域）的值，用以标识（识别）一个数据元素（或记录）。若此关键字可以识别唯一的一个记录，则称之为“主关键字”，若此关键字能识别若干记录，则称为“次关键字”。这章主要讨论的是主关键字。
若查找表中存在这样一个记录，则称“查找成功”，查找结果：给出整个记录的信信息，或指示该记录在查找表中的位置；否则称“查找不成功”，查找结果：给出“空指针”或“空记录”。

如何进行查找？
取决于查找表的结构。
然而，查找表本身是一种很松散的结构（集合，自然形成，没有规律），因此，为了提高查找的效率，需要查找表中的元素之间人为地附加某种确定的关系，换句话说，用另外一种结构来表示查找表。

### 9.1 静态查找表
ADT StaticSearchTable{
数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一标识数据元素。
数据关系R：数据元素同属一个集合。
基本操作P:Create(&ST, n); Destroy(&ST); Search(ST, key); Traverse(ST, Visit());
}
 
静态表一般为顺序存储结构：
1、顺序查找表（最简单的查找表表示方法）
以顺序表或线性链表表示静态查找表。

对查找来说我们一般不用时间复杂度表示其时间性能，一般用平均查找长度。
平均查找长度（ASL)：查找算法的平均查找长度为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。
在等概率的情况下，算法的平均查找长度为(n+1)/2
在不等概率查找的情况下，ASL在Pn>=Pn-1>=...>=P2>=p1时取极小值
若查找概率无法事先测定，则查找过程采取的改进方法是，在每次查找之后，将刚刚查找到的记录直接移至表尾的位置上。

顺序查找表用顺序查找法（因为无序），查找算法非常简单，但是平均查找长度比较大。

2、有序查找表
上述顺序查找表的查找算法简单，但平均查找长度较大，特别不适用于表长较大的查找表。
有序查找表的查找不需要用顺序查找，因为它是有序的，一般使用折半查找。

分析折半查找的平均查找长度
构建折半查找判定树（折半查找过程的描述）
一般情况下，表长为n的折半查找的判定树的深度和含有n个结点的完全二叉树的深度相同，假设n=2h次方-1并且查找概率相等，则在n>50时，ASL≈log2(n+1)-1

3、静态查找树表
不等概率查找的情况下，折半查找不是最好的查找方法（有序表无法像顺序表那样根据概率的大小移动元素）。

构造一个判定树等于设定一个查找过程。在有序表来表示静态查找表，但是查找概率不等，我们要为它设计一个查找过程，这个查找过程是用一棵二叉树来表示的，这个二叉树我们成为静态查找树。

使ASL（考虑查找不成功的情况）达到最小的判定树成为最优二叉树。
最优二叉树的构造时间复杂度是n³，同时是不等概率的情况下使用，因此使用的比较少，所以不详细讨论，如果感兴趣可查阅其他书籍。

介绍一种次优二叉树（只考虑查找成功的情况）的构造方法：选择递归选择一个二叉树的根结点，使得左右概率和之差最小。使用缩小区间查找法。用次优二叉树来表示查找表，因此这个树也叫静态查找树表。

4、索引顺序表
对比顺序表和有序表的查找性能之差别：
           顺序表                   有序表
表的特性   无序表                   有序表
存储结构  顺序结构或链表结构     只能是顺序结构，链表结构不能进行折半查找
插删操作   易于进行（放在最后即可） 需移动元素
ASL值       大                        小

索引顺序表 = 索引 + 顺序表
一般情况下，索引是一个有序表。
查找方法：
1）由索引确定记录所在的区间；
2）在顺序表的某个区间内进行查找。
所以，这也是一种缩小区间的查找方法

索引顺序表的平均查找长度为索引中进行查找的平均查找长度和在顺序表中进行查找的平均查找长度之和。

### 9.2 动态查找树表
和静态查找表不同之处在于基本操作的不同。
InitDSTable(&DT); DestroyDSTable(&DT); SearchDSTable(DT, key); InsertDSTable(&DT, e); DeleteDSTable(&T, key); TraverseDSTable(DT, Visit()):

分析上一节讨论的几种查找表的特性可得如下结论：
1）从查找性能看，最好情况能达O(logn),此时要求表有序；
2）从插入和删除的性能看，最好情况能达O(1),此时要求存储结构是链表。
所以这节就讨论这样两种特性的查找树

一、二叉排序树（二叉查找树）
二叉排序树或者是一棵空树，或者是具有如下特性的二叉树：
（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值；
（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值；
（3）它的左、右子树也都分别是二叉排序树。
通常，取二叉链表作为二叉排序树的存储结构
二叉排序树的插入和删除算法是在查找的基础上进行的。

查找性能分析，也就是求ASL（平均查找长度）。
特殊情况下形成单支树，那么整个二叉排序树的ASL就退化成了顺序排序。

二、二叉平衡树
这是另一种形式的二叉查找树，其左、右子树深度之差的绝对值不大于1。称这种特性的二叉树为平衡树。
构造二叉平衡（查找）树的方法是：在插入过程中，采用平衡旋转技术。
在二叉排序树的基础上，每次插入检查平衡因子，如果不平衡则旋转最小不平衡树，即得到二叉平衡树。

平衡树的查找性能分析：在平衡树上进行查找的过程和二叉排序树相同，因此，查找过程中给定值进行比较的关键字的个数不超过平衡树的深度。平衡树上进行查找的时间复杂度为O(log(n))

三、B-树
B-树是一种平衡的多路查找树（多叉树）：
多叉树特性：在m阶的B-树上，每个非终端结点可能含有:n个关键字，n个指向记录的指针，n+1个指向子树的指针。
查找树特性：非叶结点中的多个关键字均自小至大排列。
平衡特性：树中所有叶子结点均不带信息（空指针），且在树中的同一层次上；根结点或为叶子结点，或至少有两颗子树；其余非叶结点至少有m/2取上整课子树，至多有m棵子树。

查找过程：从根结点出发，沿指针搜索结点和在结点内进行顺序（或折半）查找两个过程交叉进行。若查找成功，则返回指向被查关键字所在结点的指针和关键字在结点中的位置；若查找不成功，则返回插入位置。

B树也是从空树开始插入构成的，和二叉排序树一样，所以它也是一种动态查找表的表示方法。

查找性能分析：B-树的查找时间主要花费在搜索结点（访问外存）上，即主要取决于B-树的深度。
在含N个关键字的B-树上进行一次查找，需访问的结点个数不超过log[m/2]((N+1)/2)+1。因此我们要设计一棵阶数m对于关键字个数N合理的的B-树。

四、B+树
B+树是B-树的一种变型。
B-树所有叶子结点不带信息，所有关键字都在叶子结点上。但是B+树相反。
B+树的结构特点：
每个叶子结点中含有n个关键字和n个指向记录的指针；并且，所有叶子结点彼此相链接构成一个有序表，其头指针指向含最小关键字的结点；
每个非叶结点（叶子结点的缩影）中的关键字Ki即为其相应指针Ai所指子树中关键字的最大值（查找树特性）；
所有叶子结点都处在同一层次上，每个叶子结点中关键字的个数均介于[m/2]和m之间
查找过程：
在B+树上，既可以进行缩小范围的查找，也可以进行顺序查找；
在进行缩小范围的查找时，不管成功与否，都必须查到叶子结点才能结束；
若在结点内查找时，给定值<=Ki，则应继续在Ai所指子树中进行查找；

插入和删除和B-树类似，也要进行分裂和合并。

五、键树
键树是一种特殊的查找树和前面的查找树有很大的不一样。

键树的结构特点：
关键字中的各个符号分布在从根结点到叶的路径上，叶结点内的符号为”结束“的标识符。因此，键树的深度和关键字集合的大小无关。
键树被约定为是一棵有序树，即同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符'$'小于任何其他符号。

键树可有两种表示方法：
1）以孩子-兄弟链表作树的存储结构（双链树）；
2）以多重链表作树的存储结构（Trie树），关键字多时采用。

实际上键树也是一棵缩影树，和B树一样。叶子结点指针指的是记录。

以上五种都是动态查找树，都有树的特性。

### 9.3 哈希表（动态查找表另一种表示方法）
一、哈希表是什么？
哈希表是基于哈希函数和处理冲突方法构造的查找表。

以上两节讨论的表示查找表的各种结构，有一个共同点：记录在表中的位置和它的关键字之间不存在一个确定的关系，因此，查找的过程为给定值依次和关键字集合中个关键字进行比较，查找的效率取决于和给定值进行比较的关键字个数。
用这类方法表示的查找表，其平均查找长度都不为零，不同表示方法的差别仅在于：和定值进行比较的关键字的顺序不同。
对于频繁使用的查找表，希望ASL=0。只有一个办法：预先知道所查关键字在表中的位置，也就是说，记录在表中位置和其关键字之间存在一种确定的关系。

一般情况，需建立一个函数关系，以f(key)作为关键字为key的记录在表中的位置，通常称这个函数f(key)为哈希函数。
简单来说，哈希表是基于哈希函数建立的一种查找表。

哈希函数特点：
1）哈希函数式一个映像（函数），即：将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可；
2）由于哈希函数式一个压缩映像（关键字集合大于地址集合），因此，在一般情况下，很容易产生”冲突“现象，即：key1不等于key2，而f(key1)=f(key2),并且，改：进哈希函数只能减少冲突，而不能避免冲突。

在设计哈希函数时，一方面要考虑选择一个“好”的哈希函数；另一方面要选择一种处理冲突方法。


二、哈希函数的构造方法（非常随意的，但是冲突要尽可能少）
对数字的关键字可有下列哈希函数的构造方法，
若是非数字关键字，则需先对其进行数字化处理。
1、直接定址法
哈希函数为关键字的线性函数H(key) = key或者H(key) = a*key + b
仅限于：地址集合的大小=关键字集合的大小

2、数字分析法
假设关键字集合中的每个关键字都是由s位数字组成（k1,k2,...,kn),分析关键字集中的全体，并从中提取分布均匀的若干位或他们的组合作为地址。
仅限于：能预先估计出全体关键字的每一位上各种数字出现的频度（知道哪几位是均匀分布的）。

3、平方取中法
若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响。

4、折叠法
若关键字的位数特别多，则可将其分割成几部分，然后取他们的叠加和为哈希地址。可有：移位叠加和间界叠加两种处理方法。

5、除留余数法
H(key) = key MOD p  p<=m(表长）
p应为不大于m的质数或是不含20以下的质因子。

6、随机数法
H(key) = Random(key) （伪随机数，是关键字的函数，不是完全和关键字无关的随机数）

实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况（包括关键字的范围和形态），总的原则是使产生冲突的可能性降到尽可能地小。

三、处理冲突的方法
处理冲突的实际含义是：为产生冲突的地址寻找下一个哈希地址。
1、开放定址法
为产生冲突的地址H(key)求得一个地址序列：
H0,H1,H2,...,Hs 1<=s<=m-1
其中：H0 = H(key)
      Hi = (H(key)+di) MOD m
      i = 1,2,...,s
也就是哈希函数加上一个增量，再对表长求余。当一开始对关键字去哈希函数得到哈希地址，如果H0没有记录则放上记录，否则放H1,一次类推。

增量di有三种取法：
1）线性探测再散列（容易引起二次聚结）
di=c*i 最简单的情况 c=1
2)平方探测再散列
di = 1²，-1²，2²，-2²，...,
3）随机探测再散列（增量和关键字有关）
di是一组伪随机数列 或者 di=i*H(key)(双散列法或双哈希法）

注意：增量di应具有“完备性”
即：产生的Hi均不相同，且所产生的s(m-1)个Hi值能覆盖哈希表中的所有地址。
则要求：
平方探测时的表长m必为4j+3的质数。
随机探测时的m和di没有公因子。

2、链地址法
将所有哈希地址相同的记录都链接在同一链表中。
链地址法不会产生二次冲突。

四、哈希表的查找
我们构造哈希表主要是用来查找。
查找过程和造表过程一致。

决定哈希表查找的ASL的因素：
1）选用的哈希函数（哈希函数的好坏决定了冲突的多少）（按照关键字的情况，尽量选择均匀的哈希函数）；
2）选用的处理冲突的方法；
3）哈希表饱和的程度，装载因子α=n/m值的大小（α越大越容易引起冲突）

一般情况下，可以认为选用的哈希函数时“均匀”的，则在讨论ASL时，可以不考虑它的因素。
哈希表的ASL是处理冲突方法和装载因子的函数。

五、哈希表的删除操作
哈希表的插入跟造表一样，插入到查找不成功的位置。

从哈希表中删除记录时，对于开放地址处理冲突法来说，要作特殊处理，相应地，要修改查找算法。

设计哈希表的顺序：首先根据平均查找长度设定一个处理冲突的方法，计算出α的范围，然后退出表长不小于某个值，然后再设计哈希函数。

六、对静态查找表
对动态查找表，哈希表平均查找长度比较小，而且插入删除方便。
对静态查找表也可以设计用哈希表作它的查找表。

对静态查找表，有时也可能找不到不发生冲突的哈希函数。即此时的哈希表的asl=0，称此类哈希函数为理想（perfect）的哈希函数。

对于查找频率很高的静态表，值得为它去寻找一种不发生冲突的哈希函数，从而可以节省大量的查找时间。

## 第十章：排序
### 10.1 概述
一、排序的定义
排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。
排序实际上是为查找服务的。折半查找ASL比顺序查找低很多。如果一个静态表在计算机里经常用到，应该让它是一个有序表，用折半查找实现它的查找。我们一般构造的都是一个无序表，所以把它变成有序表就要通过排序。

二、内部排序和外部排序
若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。；
反之，若参加排序的记录数量很大，整个序列的排序过程不可能再内存中完成，则称此类排序问题为外部排序。

三、内部排序的方法和分类
内部排序的过程是一个逐步扩大记录的有序序列长度的过程。

逐步（逐趟）扩大记录有序序列长度的方法大致有下列几类：
插入类：将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度。
交换类：通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，此方法增加记录的有序子序列的长度。
选择类：从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。
归并类：通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列长度。
其他方法：记数等等。

排序实际上是对关键字进行的，虽然有时候会省略“关键字”的描述。

### 10.2 插入排序
直接插入排序
用顺序查找查找记录的插入位置。

排序的时间分析：
实现排序的基本操作有两个：
（1）“比较”序列中两个关键字的大小；
（2）“移动”记录。
对于直接插入排序：O(n²)

折半插入排序
用折半查找查找记录的插入位置。

表插入排序
为了减少在排序过程中进行的“移动”记录的操作，必须改变排序过程中采用的存储结构。利用静态链表（数组）进行排序，并在排序完成之后，一次性地调整各个记录相互之间的位置，即将每个记录都调整到它们所应该在的位置上。

如何在排序之后调整记录序列？
算法中使用了三个指针：
p指示第i个记录的当前位置；
i指示第i个记录应在的位置；
q指示第i+1个记录的当前位置。

希尔排序（又称缩小增量排序）
基本思想：对待排记录序列先作“宏观”调整，再作“微观”调整。
所谓“宏观”调整，指的是，“跳跃式”的插入排序。
将记录序列分成若干子序列，分别对每个子序列进行插入排序
例如：将n个记录分成d个子序列。其中，d称为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为1。

### 10.3 快速排序（交换排序）
一、起泡排序
比较相邻记录，将关键字最大的记录交换到n-i+1的位置上
起泡排序的结束条件为：最后一趟没有进行“交换”
二、一趟快速排序
目标：找一个记录，以它的关键字作为“枢轴”，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。致使一趟排序之后，记录的无序序列R[s..t]将分割成两部分：R[s..i-1]和R[i+1..t]

三、快速排序
有递归来实现。递归基是low>=high-1.

四、快速排序的时间分析
递归程序要计算时间复杂度，要先推导出它的递归方程。
快排的时间复杂度大概为O(nlog2n),是所能得到的排序方法时间复杂度的最好情况。

若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n²)。
为避免出现这种情况，需在进行快排之前，进行“预处理”，即：比较R(s).key,R(t).key和R[(s+t)/2].key，然后取关键字为“三者之中”的记录为枢轴记录。
快排的最好情况就是枢轴在最中间的情况。  

### 10.4 堆排序（选择排序）
一、简单选择排序
从无序序列中选出关键字最小的记录，放到前面的有序序列中。
无论什么情况，选择排序的记录计较次数都是n²的。
上面提到的三种简单排序中，选择排序的记录移动次数最少。

二、堆排序
堆的定义：堆是满足下列性质的数列{r1,r2,..,rn}：堆顶元素是整个序列的最小值或者最大值。
堆排序既是利用堆的特性对记录序列进行排序的一种排序方法。

所谓“筛选”指的是，对一棵左/右子树均为堆的完全二叉树 ，“调整”根结点使整个二叉树为堆。

堆排序的时间复杂度分析：
1、对深度为k的堆，“筛选”所需要进行的关键字比较的次数至多为2(k-1）；
2、对n个关键字，建成深度为h(=[log2n]+1)堆，所需进行的关键字不叫的次数至多为4n；
3、调整“堆顶”n-1次，总共进行的关键字比较的次数不超过2n(log2n)
因此，堆排序的时间复杂度为O(nlogn)和快速排序的时间复杂度一样。

### 10.5 归并排序
归并排序的基本思想是：将两个或两个以上的有序子序列“归并”为一个有序序列。
在内部排序中，通常采用的是2-路归并排序。即：将两个位置相邻的有序子序列，归并为一个有序序列。
归并排序的时间复杂度也是O(nlogn)。

### 10.6 基数排序
除了上述的常用方法，还有很多其他的方法，我们只介绍一种，基数排序。

借助“多关键字排序”的思想来实现“单关键字排序”的算法。一次“分配”和“收集”称为一趟基数排序。

链式基数排序
在计算机上实现基数排序时，为减少所需辅助存储空间，应采用链表（一般用静态链表）作存储结构，即链式基数排序。

提醒注意：
1、“分配”和“收集”的实际操作仅为修改链表中的指针和设置队列的头、尾指针。
2、为查找使用，该链表尚需应用算法Arrange将它调整为有序表。

基数排序的时间复杂度为O(d(n+rd)) （一般rd远小于n，可以忽略）
其中，分配为O(n)，收集为O(rd)(rd为“基”），d为“分配-收集”的趟数。

除了可以用链表来实现，也可以用计数来实现。所以实际上内部排序还有一类做法是基于计数的思想的。

### 10.7 各种排序方法的综合比较
一、时间性能
1、平均的时间性能
时间复杂度为O(nlogn):快速排序，堆排序和归并排序。平均性能快排最好。
时间复杂度为O(n²):直接插入排序、起泡排序和简单选择排序。表插入也属于它。折半查找比较特殊，从查找上来说是O(nlogn）的，从移动的角度说是O(n²）的。
时间复杂度为O(n)：基数排序，比较特殊。
2、当待排记录序列按关键字顺序有序时，直接插入排序和起泡排序能达到O(n)的时间复杂度（基本有序时，直接插入排序是一种很好的排序算法）；快速排序的时间性能蜕化为O(n²)。简单选择不管关键字是怎么排序都是n²。
3、简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。
二、空间性能
指的是排序过程中所需的辅助空间大小。
1、所有的简单排序方法（包括：直接插入、起泡和简单选择）和堆排序的空间复杂度为O(1);
2、快速排序为O(logn),为栈所需的辅助空间（递归的），比较坏的情况可达到O(n)。
3、归并排序所需辅助空间最多，其空间复杂度为O(n);
4、链式基数排序需附设队列首尾指针，则空间复杂度为O(n+rd)（n个附加的指针）。
三、排序方法的稳定性能（对单关键字来说无所谓）
1、稳定的排序方法指的是，对于两个关键字相等的记录，他们在序列中的相对位置，在排序之前和经过排序之后，没有改变。
2、当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。
3、对于不稳定的排序方法，只要能举出一个实例说明即可。
4、快速排序、堆排序和希尔排序是不稳定的排序。跳跃式的比较都是不稳定的，相邻关键字的比较的算法是稳定的。由于基数排序没有关键字之间的比较，所以也是稳定的。
四、关于“排序方法的时间复杂度的下限”
本章讨论的各种排序方法，除基数排序外，其他方法都是基于“比较关键字”进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为O(nlogn)。（基数排序不是基于“比较关键字”的排序方法，所以它不受这个限制）

### 10.8 外部排序（需要访问外存的排序）
一、问题的提出
1、待排序的记录数量很大，不能一次装入内存，则无法利用前几节讨论的排序方法（否则将引起频繁的访问外存）；
2、对外存中数据的读/写是以“数据块”（可能包含着若干个逻辑记录）为单位进行的，并不是以用户定义的逻辑数据为单位进行的，而是以操作系统定义的数据流进行的。
读/写外存中一个“数据块”的数据所需要的时间为：
Ti/o = tseek + tla + n*twm
其中，tseek为寻查时间（查找该数据块所在磁道），tla为等待（延迟）时间，n*twm为传输数据块中n个记录的时间（数据从外存传输到内存有一个传输时间）。
二、外部排序的基本过程
外部排序是在内部排序的基础上进行的。
由相对独立的两个步骤组成：
1、按可用内存大小，利用内部排序方法，构造若干（记录的）有序子序列，通常称外存中这些记录有序子序列为“归并段”；
2、通过“归并”，逐步扩大（记录的）有序子序列的长度，直至外存中整个记录序列按关键字有序为止。

外排总的时间还应包括内部排序所需时间和逐趟归并时进行内部归并的时间，显然，出去内部排序的因素外，外部排序的时间取决于逐趟归并所需进行的“趟数”。一般内部 排序时间比访问外存的时间小得多，所以所需时间主要取决于访问外存的时间。由于每一趟外存的数据读写是和算法无关的，是操作系统决定的，所以我们只能改变“趟数”来优化时间。因此，对外排而言，通常采用多路归并。通过置换选择排序，在进行内部排序的同时，读入外存中的数据，进行内外存的置换，从而减少初始归并段个数，也可以减少归并趟数。置换选择排序归并的时候要采取最佳归并树的做法。

## 第十二章：文件
### 12.1 有关文件的基本概念
一、文件即为记录的集合，和“查找表”的差别在于，“文件”指的是存储在外存储器中的记录的集合。记录是文件中可以存取的数据的基本单位。记录本身是由多个数据项组成的。
二、文件可按其中记录的类型不同而分成两类：
其一位操作系统的文件，文件中的记录仅是一个字符组（数据流，是没有结构的）。由于操作系统中的文件仅是一维的连续字符序列，为了用户存取和加工的方便，将文件中的信息划分为若干组，其中每一组信息称作一个记录。
其二为数据库文件，文件中的记录带有结构，是数据项的集合。记录是文件中可以存取的数据基本单位，数据项是文件中可以使用的数据最小单位。
三、记录中能识别不同记录的数据项被称为关键字，若该数据项能唯一识别一个记录，则称为主关键字，若能识别多个记录则称为次关键字。
四、文件的逻辑结构指的是呈现在用户面前的文件中记录之间的逻辑关系；文件的物理结构指的是文件中逻辑记录在存储器中的组织方式。
五、文件的操作：检索、修改、排序
1、检索（比查找表讨论的要复杂一点）
顺序存取：存取“当前记录的”下一个记录；
直接存取：存取第i个记录；
按关键字存取：存取其关键字等于给定值的记录。
2、修改
往文件中插入一个或一批记录；
从文件中删除一个或一批记录；
更新文件中某个记录的属性。
3、排序
也就是外部排序。

### 12.2 顺序文件（一下各节是文件的几种常见的物理结构，即组织方法）
结构特点：
记录在文件中的排列顺序是由记录进入存储介质的次序决定的，即文件物理结构中记录的排列顺序和文件的逻辑结构中记录的排列顺序一致。类似于顺序表。

顺序文件的具体组织形式有两种：
连续文件（顺序存储）：次序相继的两个物理记录其存储位置相邻；
串联文件（链式存储）：物理记录之间的顺序由指针相链。

操作特点：
1、便于进行顺序存取；
2、不便于进行直接存取（也就是随机存取,因为记录长度可能不一样，记录也可能被删除，所以不能直接计算出地址）。
对于磁盘上的等长记录的连续文件可以进行折半查找；
一般顺序文件不进行按关键字的检索；
3、插入新的记录只能加在文件的末尾；
4、删除记录时，只作标记；文件上记录移动是很麻烦的
5、更新记录必须生成新的文件。因为记录属性改变文件的长度可能就要改变，即使长度不变也很难做到，可能会把前后记录覆盖掉。

顺序文件的插入、删除和更新操作在多数情况下都采用批处理方式。此时，为处理方便，通常将顺序文件做成有序文件，称为“主文件”，同时将所有的操作做成一个“事务文件”（经过排序也称为有序文件），所谓“批处理”，就是将这两个文件“合”为一个新的主文件。具体操作相当于“归并两个有序表”。
但有两点不同：
（1）对于事务文件中的每个操作首先要判别其“合法性”；
（2）事务文件中可能存在多个操作是对主文件中同一记录进行的。

批处理的时间分析：
假设主文件中含有n个记录，事务文件中含有m个记录，则对事务文件进行排序的时间（一般来说事务文件不是很大，是可以一次读入内存进行内部排序的）的复杂度为O(mlogm)；内部归并的时间复杂度为O(m+n),则总的内部处理的时间为O(mlogm+n)；
假设对外存进行一次读/取为s个记录，则整个批处理过程中读/写外存的次数为2()m/s+(m+n)/s)

### 12.3 索引文件
一、结构特点：
1、索引文件由“主文件”和多级“索引”组成。
2、索引中的每个记录由“关键字”和“指针”组成。
3、通常，索引文件中的主文件是无序文件（插入比较方便），索引是（按关键字有序）的有序文件。
4、“索引”是在输入数据建立文件时自动生成。初建时的“静态索引”为无序文件，经过排序后成为有序文件。
二、操作的特点：
1、检索方式为：直接存取和按关键字存取。“按关键字检索”将分两步进行：先查索引，然后根据索引中指针所指索引记录。
2、插入记录时，“记录”插入在主文件的末尾，而相应的“索引项”必须插入在索引的合适位置上。因此，如果是静态索引，最好在建索引表时留一定“空位”。
3、删除记录时，仅需删除索引表中相应的索引项即可。
4、更新记录时，应将更新后的记录插入在主文件的末尾，同时修改相应的索引项。

索引类别：
1、多级静态索引
如果索引表很大，则需要对索引表建立若干级的索引。从而减少外存访问的次数。
从索引表建立的索引称为查找表。这种索引称为非稠密索引。

2、动态索引
索引表采用查找树表（一般用的是B-树，不用B+树）或哈希表。
优点：
1）不需要建立多级索引（查找树本身就是多级索引）；
2）初建立索引不需要进行排序（建立的过程就是一个排序的过程）；
3）插入或删除记录时，修改索引方便。
用查找树表作索引时，查找索引所需访问外存次数的最大值恰为查找树的深度。
可以作索引的树表有：二叉排序树、B-树和键树。
哈希表本身也可以作为一个动态索引。

稠密索引的优点是，可以实现“预查找”，缺点是，索引表占用的存储空间大。

### 12.4 索引顺序文件
结构特点：主文件按主关键字有序，对一组记录建立一个索引项（建立非稠密索引）。
有两种典型的索引顺序文件：
一、ISAM文件
ISAM（索引顺序存取方法）是一种专为磁盘存取设计的文件组织方法。
1、文件的组织方式：
主文件按柱面集中存放，同时建立三级索引：磁道索引、柱面索引和主索引
2、操作特点：
检索：可有两种方式：
顺序存取--依关键字最小至大顺序存取。
按关键字存取--从主索引开始，到柱面索引，到磁道索引，最后取到记录，先后访问了4次外存
插入：将记录插入在某个磁道的合适位置上；将该磁道上关键字最大的记录移出到本柱面中的溢出区里；修改本磁道的索引项（包括基本索引项和溢出索引项）。
删除：在被删记录单签存储位置上做删除的标记。
3、文件重组
在经过多次的插入和删除操作之后，大量的记录进入文件的“溢出区”，而“基本存储区”中出现很多已被删去的记录空间，此时的文件结构很不合理。因此，对ISAM文件，需要周期地进行重整。

4、柱面索引的位置
ISAM文件占有多个柱面，其柱面索引本身占有一个柱面，为使“磁头”的平均移动距离最小，柱面索引应设在数据文件所占全部柱面的中间位置上。

二、VSAM文件
VSAM(Vistual Storage Access Method)文件时利用操作系统中提供的虚拟存储器的功能组织的文件，免除了用户为读、写记录时直接对外存储进行的操作，对用户而言，文件只有控制区间和控制区域等逻辑存储单位。它的索引是一棵B+树。
所以B-树和B+树的不同是他们用在不同的文件索引上。B-树用在动态索引。

控制区间（主文件的基本单位）是用户进行一次存取的逻辑单位，可看做是一个逻辑磁道。但它的实际大小和物理磁道无关。
控制区域由若干控制区间和它们的索引项组成，可看成是一个逻辑柱面。
VSAM文件初建时，每个控制区间内的记录数不足额定数，并且有的控制区间内的记录数为零。

顺序集本身是一个单链表，它包含文件的全部索引项（因此也可以对VSAM文件进行顺序存取），同时，顺序集中的每个结点即为B+树的叶子结点，索引集中的结点即为B+树的非叶结点。

文件的操作
检索：可进行顺序存取和按关键字存取（有两个头指针）；
插入：按关键字大小插入在某个适当的控制区间中，当控制区间中的记录数超过文件规定的大小时，要“分裂”控制区间，必要时，还需要“分裂”控制区域；
删除：必须“真实地”删除记录，因此要在控制区间内“移动”记录；

VSAM文件通常被作为大型索引顺序文件的标准组织方式。
其优点是：动态地分配和释放空间，不需要重组文件；能较快地实现“后插入”的记录的检索；
其缺点是：占有较多的存储空间，一般只能保持约75%的存储空间利用率。（因此，一般情况下，极少产生需要分裂控制区域的情况）

### 12.5 直接存取文件
1、和前几节讨论的文件组织方法不同，直接存取文件的特点是，由记录的关键字“直接”得到记录在外存上的映像地址。
   类似于哈希表的构造方法，根据文件中关键字的特点设计一种“哈希函数”和处理冲突的方法将记录散列到外存储设备上，又称“散列文件”或“哈希文件”。
2、哈希文件的结构：由于记录在外存上是成组存放的，因此允许多个记录映像到同一个地址上。在此，称外存储器中存放多个记录的“数据块”为“桶”。因此由哈希函数得到的函数映像地址为“桶地址”。
   在哈希文件中，“冲突”和“溢出”是不同的概念。一般情况下，假设桶的大小为m，则允许哈希地址产生m-1次的冲突，当发生地m次冲突时，才需要进行“冲突处理”，对散列文件而言，通常采用链地址法处理冲突。为区别起见，称直接“散列”的数据块为“基桶”，而因“溢出”存放的数据块为“溢出桶”。
3、文件的操作
检索：只能进行按关键字的查找，不能进行顺序查找。检索时，先在基桶内进行查找，若不存在，则再到溢出桶中进行查找。
插入：当查找不成功时，将记录插入在相应的基桶或溢出桶内。
删除，对被删记录作特殊标记（跟哈希表一样）。
4、优点：记录随机存放，不需要进行排序；插入、删除方便，存取速度快；节省存储空间，不需要索引区。
缺点：不能进行顺序存取；在经过多次插入和删除操作之后，需进行“重组文件”操作。

### 12.6 多关键字文件
文件的结构(三种基本文件结构):顺序文件、索引文件和散列文件。
多关键文件的主文件结构可以用三种基本文件结构的任意一种来组织。
一、多关键字文件的特点
除需要对主关键字建立“主索引”外，尚需对各个次关键字建立“次索引”。
二、次索引的组织方法
1、多重链表文件：将所有具有相同次关键字的记录链接在同一链表中，该链表的头指针即为次索引项中“指针域”的值。
2、倒排文件：将所有相同次关键字的记录构成一个次索引顺序表，此时的次索引顺序表中仅存放记录的“主关键字”或记录的“物理记录号”。次索引项中的“指针”指向相应的次索引顺序表。
3、次关键字索引表本身的结构可以是顺序表，也可以是树表或哈希表，视具体的次关键字的特性而定。

判定树描述了整个查找过程，所以也称为查找树。
二叉排序树主要是动态查找表的一种表示方法，它的特点是插入删除方便。如果是静态查找表，关键字已经知道了，就没必要建这样一棵二叉排序树，而应该是排序之后变成一个静态查找树（不等概率情况，构造一棵最优查找树）或表（等概率情况下）。因为有序表的折半查找的平均查找长度时比二叉排序树小的，因为二叉排序树不一定是完全二叉树。
静态查找表，如果不是等概率的折半查找就不是最好的方法，而是应该按照静态查找树来查找（这个需要构造最优查找树）。
对于动态查找表，可以构建二叉平衡树（插入过程进行平衡转化），虽然不能跟折半查找的判定树一样但是比特殊情况下的二叉排序树好多了。
树表里头还有B-树和B+树，这些树插入删除的方法要进行分裂和合并。
B-树B+树和键树主要是作为文件的索引。
二叉排序树在中序遍历下是有序的。
哈希表的平均查找长度随关键字增加而增加，取决于不同处理冲突方法的装载因子α

直接插入排序最好的情况是基本待排序列基本有序。
快速排序最坏的情况是待排序列基本有序。
选择排序其实还有一种树型选择排序，堆排序是在它的基础上形成的。比赛的名名次排序需要用到树型选择排序。

外部排序的过程是在内部排序的基础上来进行多路归并来实现的，它的时间主要取决于外存的读写次数，也就是主要取决于归并的趟数。

语句的频度指的是语句执行的次数，而时间的复杂度是一个数量级的概念。




