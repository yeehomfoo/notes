# C 语言学习  
  
标签（空格分隔）： learning  
  
## 2、变量、运算符和表达式  
计算机通过二进制补码的形式将数字存储在内存中  
  
怎么样在内存中存储数据？  
比如：在内存中存储数字5  
在内存中存储信息首先要规定开辟多少空间供存储  
int a = 5；//在内存中开辟4字节空间（Int），为了找到这4字节，  
//起个名字叫做a，将数字5，存储到这个空间里（存数据先开辟空间）  
printf("%d\n", a); //将这4字节空间(a)的内容打印到屏幕上，打印long要用%ld  
%d当做十进制打印（有符号） %o 当做8进制打印  %x 当做十六进制打印 %u 当成无符号数来打印  
  
不看怎么存（因为存了之后都一样，都是二进制），  
只看怎么读（计算机存储规则：无论你存的数是8或10进制，计算机都是2进制补码形式）  
  
unsigned:无符号，没有符号位，所有位都用来表示大小。依然是不看怎么存，不管un不un  
32位写起来太麻烦，一般用16进制表示，比如-1的补码就是：0xFFFFFFFF  
  
除了数字，计算机还可以存字符'A' '*' （单引号表示一个字符） char  
%c 当做字符打印  
计算机如何存储字符：计算机用一个数字代表一个字符 A在内存中存的就是数字65  
ASCII码表表示每一个字符在内存中是怎么存储的（以数字多少来存储）  
char并不是字符变量（c语言没有真正意义上的字符标量，JAVA有），仍然是整形，1个字节  
同样有unsigned char  
sizeof关键字用来求一个类型，一个变量或者一个常量的大小  
c语言中字符默认是INT占用4个字节。用CHAR来装是因为ASCII码最大值是127，一个CHAR就刚好够了  
c语言整形之间（int、char、short），都可以互相赋值。当长字节数赋给短空间的时候发生截断  
截断：从低位开始存，高位存不下就不要了。  
当短整形赋给长整形时，会发生位扩展  
位扩展：仍然是从低位开始存，存完后剩下的正数补0，负数补1（补码形式下进行）  
  
实型（小数，相对于整形）浮点型F（有效数字6-7），双精度型D（有效15-16） 长双精度型  
打印实行用%f：默认打印小数点后6位。%.2f：保留小数点后2位  
读取数字 scanf("%d%d",&a,&b)(%d不要随便加空格回车)表示从终端读入一个数字交给a，再读入第二个数字交给b  
%c读字符  
  
## 三、流程控制语句  
条件判断、条件选择语句  
跳转语句 goto 标号：标示符加冒号（定格），如：A:  goto A;goto改变程序的运行顺序，跳转到标号的位置继续执行  
标号不是;结尾，不是一条语句，什么都不做  
switch语句同样是跳转语句 作逻辑选择  
  
## 十二、预处理（后篇）  
宏语句不是C语句，它不以分号结尾。在宏的眼中，没有C语法。  
预处理就是单纯的宏替换，宏替换就是单纯的字符串替换。在宏的眼中，没有变量，常量，C语法。  
宏的作用：对于反复使用的数字或者常量，可以方便修改，增加可读性。  
	  宏可以传参数，#define p(a) a++ 比如：b先把参数替换掉a，再替换b++  
```  
#define ADD(a, b) a + b   
ADD(3，5) * ADD（1,2）//单纯的字符替换：3 + 5 * 1 + 2 == 10;不会进行运算，运算时编译运行时才会执行  
```  
NULL就是一个宏，#define NULL (void *)0 //是一个强转为void *类型的0，表示空指针  
  
typedef关键字：用来给一个变量类型起一个别名，是一个C语句，用分号结尾。一般自创的类型用_t结尾表示type如size_t  
如何声明一个变量就如何声明一个类型的别名（变量类型）。  
宏不是C语句，无视C语法，没有作用域限制，从声明位置开始到文件结束都生效  
typedef只能在作用域（一对大括号就是一个单独的作用域）内生效。  
  
十三、文件操作  
文件操作：  
读 文件-->内存  
写 内存-->文件  
  
要读写，首先要打开文件  
FILE 是一个结构体的宏，在stdlib.h中  
```c  
FILE *fp = fopen("./file", "r"); // r:只读的方式打开文件。打开有可以失败  
if(!fp){  
  perror("fopen");  
  exit(-1);  
}  
fclose(fp);//使用完毕之后要关闭文件，fp指针就表示一个文件。  
```  
  
程序时没有权限的，有权限的是用户，权限取决于使用程序的人。没有权限的时候打开文件可能会失败  
unix中，在命令前加sudo会在那一瞬间拥有root权限（最高权限）  
  
打开文件之后可以进行读取或者写操作：  
```c  
freed(); // 读  文件-->内存   
fwrite(); // 写 内存-->文件  
```  
  
  
  
  
