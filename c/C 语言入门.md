# C 语言入门  
  
标签（空格分隔）： learning  
  
## 一、数字的进制转换  
计算机以二进制存储数据  
  
十进制：-5  
二进制：-0b101  
八进制：-05  
十六进制：-0x5  
  
内存实际上就是一大堆开关 不同内存以不同状态表示开或关  
计算机先开辟空间再存储数据  
计算机分配内存每次最少1字节（相邻的8位）  
  
正数的原码、反码和补码一致  
-5  
-0b101  
负数原码 1000 0101 （一字节，最高位表示符号,后七位表示其大小）  
负数反码 1111 1010 （在原码的基础上，符号位不变，其他位按位取反）  
负数补码 1111 1011 （在反码的基础上加1，得到的是补码）  
  
无论正数负数，在内存中都是以补码形式储存的  
比如：计算机在内存中用一个字节存储-1 则是在内存中存储了8个1  
当两个8位的数字相加是，若位9位，从低位开始存，最高位存不下则舍去  
  
对补码再求一次补码就是原码  
1110 1011 补码  
1001 0100 先转换成反码（日常使用的二进制更接近于原码，而计算机为了方便减法计算  
存储的是补码，反码只是用于原码和补码之间的转换没有实际意义）  
1001 0101 在反码的基础上加1就是原码  
  
  
## 四、数组  
数组可以部分初始化，也可以完全初始化  
  
数组不能完全赋值，只能一个一个的赋值  
  
## 五、指针  
指针在64位的系统下，所有的指针都是8个字节的变量（32位系统4字节）  
一个变量的地址就是它第一个字节的地址  
*p：找到地址为P的这个空间，即变量第一字节的位置，从这个位置开始去*p个字节，得到的就是这个变量的 值  
  
地址是常量，指针是变量。只有变量才有地址，变量本质上是内存上的空间。  
  
单独的数组名，比如a相当于其第一个元素的地址，即&a[0].数组名是数组的首元素地址。  
指针变量加1，其结果相当于加1个其指向的字节数。  
指针和整形相加，整形向指针看齐。用p%打印地址。  
  
[]中括号运算符就是加i取星。p[1] == *(p+1)  
a[3]代表*（a +3） 3[a] 代表 3 + a取星，所以他们是一样的  
指针是地址变量，数组名是地址常量，不一样。因此数组不能整体赋值，数组名a仅仅是代表a[0]的地址。  
  
const关键字可以修饰指针变量：  
const在星前表示修饰*p，p可以变，但是*p不可变。const在星后则相反。char const * p or const char * p  
  
## 六、函数  
可以将一些繁琐的，反复使用的，重复使用的代码，封装成一个函数。  
void表示空，可以理解为没有。  
返回值就是函数调用表达式的值。  
不能返回一个函数内的局部变量的地址。因为局部变量都会随着所在函数的调用完毕而消失。  
返回不存在的变量的地址，不安全。  
原则上不可以返回一个即将消失的变量的地址。  
函数以栈形式调用，一开始只有Main函数的栈，变量占栈空间的一部分  
  
参数括号里写void表示没有参数，有参数则写变量，称为形参。  
传参的参数叫实参。传参就是用实参给形参赋值。  
  
值传递：传a就是穿a的值，两个函数里的a不是同一个内存空间  
地址传递：要修改一个变量，传参传变量的地址。  
  
const int * a   （a+1）的类型最后是a的类型，仍然是const int * 类型  
  
## 七、复杂类型确认  
  
sizeof一个变量和sizeof一个变量的类型，其结果是相同的。盖住变量名，剩下部分就是该变量的类型  
  
平级的优先级一般为右结合。int *p[10] 从优先级上讲离方括号近，所以它首先是一个数组，它的每个元素是指向整形的指针  
int (*p)[10]是一个指向数组的指针（中括号其实就是*（p + i），平级时右结合P靠近[]）。指针p是什么类型，就看*p是什么类型。  
指针都是8字节的，没有区别，区别在于它们的指向，即*p就是它的指向，或者说是它的类型。  
数组a与地址，&a从数值上来说和a（a[0]，即是数组的地址）是一样的。 但是它们的类型不同，通过*找到同样的地址后，取得字节数不同。  
二维数组要传参必须要用指向一维数组的指针来接收它。int a[5][4]，变量名a代表a[0]，盖住a[0]可知其类型为int [4]  
int **p p离*最近，所以他是一个指针，它指向另一种指针，该指针指向整形。二级指针。  
  
NULL表示零的意思，是可以付给指针的零，即空指针  
  
返回值不一定在函数的前面。 int (* func(void)[10]) func离括号（void）最近，圆括号代表一个函数。该函数的返回值是int (*p) [10]  
  
int * p(int)这是一个函数，因为它离圆括号最近，它的参数是一个整形，调用一个函数，剩余部分就是函数表达式的值（返回值），即int*  
int (*p) (int) p离星号最近，所以他是一个指针，它的指向（把*p看做一个整体）即int a (int) 所以它指向参数是int返回值是Int的函数，函数指针。  
  
函数指针用来指向一个函数。int (*p)(int, int) = add; int add(int a, int b)。函数名是函数的入口地址。p(5,4) == ad(5,4)  
  
复杂类型确认举例：  
int (*(*p[10])(int))(int);p离数组（方括号）最近，所以它是一个数组，它的元素是什么类型？把它的元素P[10]看做一个整体  
int (*(*A)(int))(int);A离*最近，所以数组的元素是某种指针  
int (*A(int))(int);指针A取星，A离圆括号最近，所以指向函数，该种函数的参数是int，返回值是调用这个函数之后函数调用表达式的值  
int (*A) (int) 返回值是另一种指针，取星  
int A (int),该指针指向参数int，返回值int的函数。  
这个数组的大小是80个字节。sizeof(int(*(*[10])(int))(int))  
  
## 八、字符串  
"hello world!"这个字符串由13个字符组成，在所有的字符后面还有一个你看不见的字符‘\0’（字符用单引号）  
'\0'尾零，表示一个字符串的结尾。比如：  
"h" 是一个字符串由2个字符组成'h' '\0' 在字符串中每个字符占一个字节，所以它在内存中占用2个字节。  
'h' 实际上是以一个数字的形式存储在内存中，是4个字节  
声明一个字符串 char * a = "123"  
%s打印字符串  
两句话（字符串特点）：  
1、当我们写“hello”时，就是告诉编译器在只读数据段存储6个字符。有效字节长（不包括尾零）：5  
只读数据段：离栈（每调用一个函数都会压一个栈空间）很远的地方，专门有一段内存用来存储一些只读的数据，和栈是并列的关系。  
2、'hello'表达式的值，表示字符串第一个字符‘h’的地址。所以可以赋值给char型指针。  
尾零作为一个字符虽然打印出来了，但是它是不可见的  
只读数据段的一个特点就是内容不可更改。  
除了用指针指向字符串，也可以用字符串给数组初始化。数组在栈里，可以修改。  
  
strlen() 这个函数，传入字符串的首字符地址，返回long类型的的字符串有效长度值（到第一个尾零前）  
sizt_t 其实就是unsign long。除非数值非常大，否则%u和%d打印出来的值是一样的  
  
在unix/linux 下man 加函数名 表示查看函数的使用方法。  
  
stdlib.h stadard c library includes some string operating fundations  
atoi() 函数把字符串转换成这个字符串所表示的数字，遇到非法字符就会停止  
如：“-123-123”== -123 第二个负号为非法字符  
在string.h中  
strcmp(const char *s1, const char *s2) 一般参数是字符指针，传入的通常是字符串。字符串比较函数  
不能使用关系运算符来比较字符串的大小：“abc”>"abd",因为他们是两个地址，与字符串大小无关。  
strcpy()拷贝，必须保证有足够的空间。  
strcat()字符串的拼接，拼接之后只有一个尾零  
strstr()查找字符串。找不到返回char *ret = NULL。找到则返回子串最早在字符串中出现的位置的地址。  
strtok()字符串分割函数，只能分割可变字符串，以分割符为准，将字符串分割，返回第一个分割出的字符，传空表示继续分割之前的字符串  
  
在*后面的关键字restrict表示指针约束。  
  
一个指针拥有不确定指向，我们称为野指针。char *q;指向不确定有可能指向空，则拷贝会发生段错误。  
  
## 九、位运算  
针对变量某一位的操作称之为位运算（位操作）  
称最低位为第0位  
位运算符：  
& 按位与 表示对每一位进行与运算 5&3 == 1 位运算时用的是补码 5&-1 == 5  
| 按位或 对数字的每一位进行或运算   
^ 按位异或 不同位1 相同位0  
~ 按位取反 一个数取反等于其相反数减1  
<< 左移 每一位都向左移一位，超出范围舍去，后面补零。一个数左移一位相当于乘以2，左移两位乘以4，左移N位相当于乘2的n次方  
>> 右移 不同的系统下右移的结果不同（不0或者补符号位）。正数右移，移出舍出，前面补零。正数右移N位相当于除以2的N次方；负数右移，舍去最低位，前面补1  
   5>>1(5本身没有改变，只不过表达式的值是右移之后的值)  
  
单独对一位操作（位运算）：  
查看a的某一位  
如果想求a的第N位（0位起）是1还是0。  
a&(1 << n) == 1 则第N位是1，反之则反之  
将a的第n位置1  
a = a | (1 << n) or a |= 1 << n   
将a的第n位置0  
a &= ~（1 << n）  
将a的第n位取反  
a ^= 1 << n  
  
## 十、结构体和枚举  
结构体：不同类型变量的集合。（数组是相同类型变量的集合）创建结构体只是创建一个类型，并没有分配空间  
声明一个结构体变量相当于声明了所有的结构体成员，占用空间。  
结构体可以直接用大括号初始化（类似数组）。  
p->a 取星再取点，等价于 （*p）.a。* & .平级，右结合  
  
枚举：用自定义字符串（标识符）成员代替0 1 2 3...增加程序的可读性。当我们写到这些标识符时，它们就代表相应的数值  
enum{  
	aa,//0  
	bb,//1  
	cc = 4, //4 赋值位置之后的枚举值都会跟着改变  
	dd,//5  
	ee = -1,  
	ff //0 与aa一样，枚举允许不同标识符代表相同的值  
};  
  
## 十一、动态内存分配  
stdlib.h 中的malloc函数，可以动态分配内存  
void *malloc(size_t size);//size_t 是unsign long,表示要开劈多少字节的空间。返回一个void * 泛型指针（第一个字节的地址），可以赋给任何一个指针类型的变量  
动态内存开辟的空间在“堆段”  
函数的空间在”栈段“（调用函数时会产生栈空间），调用MAIN函数会产生一个叫MAIN的栈的空间  
新产生的栈在原来的栈下面，新产生的堆在旧的堆上面（下面是低地址，上面是高地址）  
栈向下压，堆向上堆。  
堆空间的开辟有一定的几率失败（几率很小），失败时返回值位NULL（NULL的意思就是0）。  
通过返回的指针来使用堆空间  
堆使用完毕时候要释放free(堆空间第一字节的地址);//释放不是把堆中所有的内容清0，只是把占用（使用权）释放。  
如果不使用free函数释放，除非程序（进程）结束，否则这个空间是不会释放的  
返回即将消失的栈中变量时不安全的，堆中的空间不会随调用函数的栈空间的消失而消失，只有程序结束，或者使用FREE才会消失  
开辟堆空间不要忘了报错  
int *p = malloc(4);  
if (!p){//!p和p==null是一样的  
	perror("malloc");  
	exit(-1);  
}  
  
栈空间是静态内存分配（变量声明占用多大空间是在我们编译代码的时候就已经决定了），编译器看到声明的变量就认为是开辟相应字节的空间，把这些空间加在（main）栈中  
堆空间是动态内存分配 程序运行时可以随时调整需要的空间的大小 大小是运行时决定的  
  
动态                       静态  
大小运行时决定             大小编译时决定  
程序员分配                 编译器分配（我们只是声明变量，分配由编译器决定。不同编译器Int开辟的栈空间大小可能不同）  
堆段                       栈段 数据段 只读数据段（栈空间函数调用结束时释放，其他在程序结束时释放）  
手动释放                   自动释放  
  
## 十二、预处理  
编译分为4个步骤：  
1、.c文件生成.i文件//预处理（不考虑语法，只是单纯的展开、替换） 都是C语法  
2、.i文件生成.s文件//编译  C -> 汇编（c语言告诉系统生成一个整形变量，汇编告诉系统如何生成一个整形变量）  
3、.s文件生成.o文件//汇编  
4、.o文件生成.exe文件//链接  
  
预处理：展开头文件、替换宏  
声明宏#define N 6 //凡是使用N就是使用了6  
宏：发生在预处理阶段的单纯的字符串替换。（宏的名字是一个标识符）  
  
冒泡排序 by num_produce  
//	for(j=1;j<length;j++)//冒泡排序（鉴于排序的频繁使用，可见排序算法的重要性。算法先于代码）  
//		for(i=0;i<length-j;i++)  
//			if(t[i].num_produce>t[i+1].num_produce)  
//			{  
//				temp=t[i];  
//				t[i]=t[i+1];  
//				t[i+1]=temp;  
//			}    
getchar()实际上是从缓冲区取数据  
  
  
  
  
